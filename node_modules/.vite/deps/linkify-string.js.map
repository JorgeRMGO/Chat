{
  "version": 3,
  "sources": ["../../linkifyjs/dist/linkify.es.js", "../../linkify-string/dist/linkify-string.es.js"],
  "sourcesContent": ["// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\r\n// See update-tlds.js for encoding/decoding format\r\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\r\nconst encodedTlds = 'aaa1rp3barth4b0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re2s2c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y0eats7k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking0channel11l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t0isalat7u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0at2delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d0network8tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0eles2s3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster5ia3d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0cys3drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7serati6ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic3tual5v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rthwesternmutual14on4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cher3ks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w0time7i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0channel7ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\u00F6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u0elos6wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\r\n// Internationalized domain names containing non-ASCII\r\nconst encodedUtlds = '\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u062A\u0635\u0627\u0644\u0627\u062A6\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2';\r\n\r\n/**\r\n * @template A\r\n * @template B\r\n * @param {A} target\r\n * @param {B} properties\r\n * @return {A & B}\r\n */\r\nconst assign = (target, properties) => {\r\n  for (const key in properties) {\r\n    target[key] = properties[key];\r\n  }\r\n  return target;\r\n};\r\n\r\n/**\r\n * Finite State Machine generation utilities\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ [group: string]: T[] }} Collections\r\n */\r\n\r\n/**\r\n * @typedef {{ [group: string]: true }} Flags\r\n */\r\n\r\n// Keys in scanner Collections instances\r\nconst numeric = 'numeric';\r\nconst ascii = 'ascii';\r\nconst alpha = 'alpha';\r\nconst asciinumeric = 'asciinumeric';\r\nconst alphanumeric = 'alphanumeric';\r\nconst domain = 'domain';\r\nconst emoji = 'emoji';\r\nconst scheme = 'scheme';\r\nconst slashscheme = 'slashscheme';\r\nconst whitespace = 'whitespace';\r\n\r\n/**\r\n * @template T\r\n * @param {string} name\r\n * @param {Collections<T>} groups to register in\r\n * @returns {T[]} Current list of tokens in the given collection\r\n */\r\nfunction registerGroup(name, groups) {\r\n  if (!(name in groups)) {\r\n    groups[name] = [];\r\n  }\r\n  return groups[name];\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {T} t token to add\r\n * @param {Collections<T>} groups\r\n * @param {Flags} flags\r\n */\r\nfunction addToGroups(t, flags, groups) {\r\n  if (flags[numeric]) {\r\n    flags[asciinumeric] = true;\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[ascii]) {\r\n    flags[asciinumeric] = true;\r\n    flags[alpha] = true;\r\n  }\r\n  if (flags[asciinumeric]) {\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[alpha]) {\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[alphanumeric]) {\r\n    flags[domain] = true;\r\n  }\r\n  if (flags[emoji]) {\r\n    flags[domain] = true;\r\n  }\r\n  for (const k in flags) {\r\n    const group = registerGroup(k, groups);\r\n    if (group.indexOf(t) < 0) {\r\n      group.push(t);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {T} t token to check\r\n * @param {Collections<T>} groups\r\n * @returns {Flags} group flags that contain this token\r\n */\r\nfunction flagsForToken(t, groups) {\r\n  const result = {};\r\n  for (const c in groups) {\r\n    if (groups[c].indexOf(t) >= 0) {\r\n      result[c] = true;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @template T\r\n * @typedef {null | T } Transition\r\n */\r\n\r\n/**\r\n * Define a basic state machine state. j is the list of character transitions,\r\n * jr is the list of regex-match transitions, jd is the default state to\r\n * transition to t is the accepting token type, if any. If this is the terminal\r\n * state, then it does not emit a token.\r\n *\r\n * The template type T represents the type of the token this state accepts. This\r\n * should be a string (such as of the token exports in `text.js`) or a\r\n * MultiToken subclass (from `multi.js`)\r\n *\r\n * @template T\r\n * @param {T} [token] Token that this state emits\r\n */\r\nfunction State(token) {\r\n  if (token === void 0) {\r\n    token = null;\r\n  }\r\n  // this.n = null; // DEBUG: State name\r\n  /** @type {{ [input: string]: State<T> }} j */\r\n  this.j = {}; // IMPLEMENTATION 1\r\n  // this.j = []; // IMPLEMENTATION 2\r\n  /** @type {[RegExp, State<T>][]} jr */\r\n  this.jr = [];\r\n  /** @type {?State<T>} jd */\r\n  this.jd = null;\r\n  /** @type {?T} t */\r\n  this.t = token;\r\n}\r\n\r\n/**\r\n * Scanner token groups\r\n * @type Collections<string>\r\n */\r\nState.groups = {};\r\nState.prototype = {\r\n  accepts() {\r\n    return !!this.t;\r\n  },\r\n  /**\r\n   * Follow an existing transition from the given input to the next state.\r\n   * Does not mutate.\r\n   * @param {string} input character or token type to transition on\r\n   * @returns {?State<T>} the next state, if any\r\n   */\r\n  go(input) {\r\n    const state = this;\r\n    const nextState = state.j[input];\r\n    if (nextState) {\r\n      return nextState;\r\n    }\r\n    for (let i = 0; i < state.jr.length; i++) {\r\n      const regex = state.jr[i][0];\r\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\r\n      if (nextState && regex.test(input)) {\r\n        return nextState;\r\n      }\r\n    }\r\n    // Nowhere left to jump! Return default, if any\r\n    return state.jd;\r\n  },\r\n  /**\r\n   * Whether the state has a transition for the given input. Set the second\r\n   * argument to true to only look for an exact match (and not a default or\r\n   * regular-expression-based transition)\r\n   * @param {string} input\r\n   * @param {boolean} exactOnly\r\n   */\r\n  has(input, exactOnly) {\r\n    if (exactOnly === void 0) {\r\n      exactOnly = false;\r\n    }\r\n    return exactOnly ? input in this.j : !!this.go(input);\r\n  },\r\n  /**\r\n   * Short for \"transition all\"; create a transition from the array of items\r\n   * in the given list to the same final resulting state.\r\n   * @param {string | string[]} inputs Group of inputs to transition on\r\n   * @param {Transition<T> | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   */\r\n  ta(inputs, next, flags, groups) {\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      this.tt(inputs[i], next, flags, groups);\r\n    }\r\n  },\r\n  /**\r\n   * Short for \"take regexp transition\"; defines a transition for this state\r\n   * when it encounters a token which matches the given regular expression\r\n   * @param {RegExp} regexp Regular expression transition (populate first)\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  tr(regexp, next, flags, groups) {\r\n    groups = groups || State.groups;\r\n    let nextState;\r\n    if (next && next.j) {\r\n      nextState = next;\r\n    } else {\r\n      // Token with maybe token groups\r\n      nextState = new State(next);\r\n      if (flags && groups) {\r\n        addToGroups(next, flags, groups);\r\n      }\r\n    }\r\n    this.jr.push([regexp, nextState]);\r\n    return nextState;\r\n  },\r\n  /**\r\n   * Short for \"take transitions\", will take as many sequential transitions as\r\n   * the length of the given input and returns the\r\n   * resulting final state.\r\n   * @param {string | string[]} input\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  ts(input, next, flags, groups) {\r\n    let state = this;\r\n    const len = input.length;\r\n    if (!len) {\r\n      return state;\r\n    }\r\n    for (let i = 0; i < len - 1; i++) {\r\n      state = state.tt(input[i]);\r\n    }\r\n    return state.tt(input[len - 1], next, flags, groups);\r\n  },\r\n  /**\r\n   * Short for \"take transition\", this is a method for building/working with\r\n   * state machines.\r\n   *\r\n   * If a state already exists for the given input, returns it.\r\n   *\r\n   * If a token is specified, that state will emit that token when reached by\r\n   * the linkify engine.\r\n   *\r\n   * If no state exists, it will be initialized with some default transitions\r\n   * that resemble existing default transitions.\r\n   *\r\n   * If a state is given for the second argument, that state will be\r\n   * transitioned to on the given input regardless of what that input\r\n   * previously did.\r\n   *\r\n   * Specify a token group flags to define groups that this token belongs to.\r\n   * The token will be added to corresponding entires in the given groups\r\n   * object.\r\n   *\r\n   * @param {string} input character, token type to transition on\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  tt(input, next, flags, groups) {\r\n    groups = groups || State.groups;\r\n    const state = this;\r\n\r\n    // Check if existing state given, just a basic transition\r\n    if (next && next.j) {\r\n      state.j[input] = next;\r\n      return next;\r\n    }\r\n    const t = next;\r\n\r\n    // Take the transition with the usual default mechanisms and use that as\r\n    // a template for creating the next state\r\n    let nextState,\r\n      templateState = state.go(input);\r\n    if (templateState) {\r\n      nextState = new State();\r\n      assign(nextState.j, templateState.j);\r\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\r\n      nextState.jd = templateState.jd;\r\n      nextState.t = templateState.t;\r\n    } else {\r\n      nextState = new State();\r\n    }\r\n    if (t) {\r\n      // Ensure newly token is in the same groups as the old token\r\n      if (groups) {\r\n        if (nextState.t && typeof nextState.t === 'string') {\r\n          const allFlags = assign(flagsForToken(nextState.t, groups), flags);\r\n          addToGroups(t, allFlags, groups);\r\n        } else if (flags) {\r\n          addToGroups(t, flags, groups);\r\n        }\r\n      }\r\n      nextState.t = t; // overwrite anything that was previously there\r\n    }\r\n\r\n    state.j[input] = nextState;\r\n    return nextState;\r\n  }\r\n};\r\n\r\n// Helper functions to improve minification (not exported outside linkifyjs module)\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {RegExp} regexp\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string} input\r\n * @param {T | State<T>} [next]\r\n * @param {Collections<T>} [groups]\r\n * @param {Flags} [flags]\r\n */\r\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\r\n\r\n/******************************************************************************\r\nText Tokens\r\nIdentifiers for token outputs from the regexp scanner\r\n******************************************************************************/\r\n\r\n// A valid web domain token\r\nconst WORD = 'WORD'; // only contains a-z\r\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\r\n\r\n// Special case of word\r\nconst LOCALHOST = 'LOCALHOST';\r\n\r\n// Valid top-level domain, special case of WORD (see tlds.js)\r\nconst TLD = 'TLD';\r\n\r\n// Valid IDN TLD, special case of UWORD (see tlds.js)\r\nconst UTLD = 'UTLD';\r\n\r\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\r\n// `file`, and user-defined custom protocols. Limited to schemes that contain\r\n// only letters\r\nconst SCHEME = 'SCHEME';\r\n\r\n// Similar to SCHEME, except makes distinction for schemes that must always be\r\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\r\n// `ftp`, `ftps`\r\nconst SLASH_SCHEME = 'SLASH_SCHEME';\r\n\r\n// Any sequence of digits 0-9\r\nconst NUM = 'NUM';\r\n\r\n// Any number of consecutive whitespace characters that are not newline\r\nconst WS = 'WS';\r\n\r\n// New line (unix style)\r\nconst NL$1 = 'NL'; // \\n\r\n\r\n// Opening/closing bracket classes\r\nconst OPENBRACE = 'OPENBRACE'; // {\r\nconst OPENBRACKET = 'OPENBRACKET'; // [\r\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\r\nconst OPENPAREN = 'OPENPAREN'; // (\r\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\r\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\r\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\r\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\r\n\r\n// Various symbols\r\nconst AMPERSAND = 'AMPERSAND'; // &\r\nconst APOSTROPHE = 'APOSTROPHE'; // '\r\nconst ASTERISK = 'ASTERISK'; // *\r\nconst AT = 'AT'; // @\r\nconst BACKSLASH = 'BACKSLASH'; // \\\r\nconst BACKTICK = 'BACKTICK'; // `\r\nconst CARET = 'CARET'; // ^\r\nconst COLON = 'COLON'; // :\r\nconst COMMA = 'COMMA'; // ,\r\nconst DOLLAR = 'DOLLAR'; // $\r\nconst DOT = 'DOT'; // .\r\nconst EQUALS = 'EQUALS'; // =\r\nconst EXCLAMATION = 'EXCLAMATION'; // !\r\nconst HYPHEN = 'HYPHEN'; // -\r\nconst PERCENT = 'PERCENT'; // %\r\nconst PIPE = 'PIPE'; // |\r\nconst PLUS = 'PLUS'; // +\r\nconst POUND = 'POUND'; // #\r\nconst QUERY = 'QUERY'; // ?\r\nconst QUOTE = 'QUOTE'; // \"\r\n\r\nconst SEMI = 'SEMI'; // ;\r\nconst SLASH = 'SLASH'; // /\r\nconst TILDE = 'TILDE'; // ~\r\nconst UNDERSCORE = 'UNDERSCORE'; // _\r\n\r\n// Emoji symbol\r\nconst EMOJI$1 = 'EMOJI';\r\n\r\n// Default token - anything that is not one of the above\r\nconst SYM = 'SYM';\r\n\r\nvar tk = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tWORD: WORD,\r\n\tUWORD: UWORD,\r\n\tLOCALHOST: LOCALHOST,\r\n\tTLD: TLD,\r\n\tUTLD: UTLD,\r\n\tSCHEME: SCHEME,\r\n\tSLASH_SCHEME: SLASH_SCHEME,\r\n\tNUM: NUM,\r\n\tWS: WS,\r\n\tNL: NL$1,\r\n\tOPENBRACE: OPENBRACE,\r\n\tOPENBRACKET: OPENBRACKET,\r\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\r\n\tOPENPAREN: OPENPAREN,\r\n\tCLOSEBRACE: CLOSEBRACE,\r\n\tCLOSEBRACKET: CLOSEBRACKET,\r\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\r\n\tCLOSEPAREN: CLOSEPAREN,\r\n\tAMPERSAND: AMPERSAND,\r\n\tAPOSTROPHE: APOSTROPHE,\r\n\tASTERISK: ASTERISK,\r\n\tAT: AT,\r\n\tBACKSLASH: BACKSLASH,\r\n\tBACKTICK: BACKTICK,\r\n\tCARET: CARET,\r\n\tCOLON: COLON,\r\n\tCOMMA: COMMA,\r\n\tDOLLAR: DOLLAR,\r\n\tDOT: DOT,\r\n\tEQUALS: EQUALS,\r\n\tEXCLAMATION: EXCLAMATION,\r\n\tHYPHEN: HYPHEN,\r\n\tPERCENT: PERCENT,\r\n\tPIPE: PIPE,\r\n\tPLUS: PLUS,\r\n\tPOUND: POUND,\r\n\tQUERY: QUERY,\r\n\tQUOTE: QUOTE,\r\n\tSEMI: SEMI,\r\n\tSLASH: SLASH,\r\n\tTILDE: TILDE,\r\n\tUNDERSCORE: UNDERSCORE,\r\n\tEMOJI: EMOJI$1,\r\n\tSYM: SYM\r\n});\r\n\r\n// Note that these two Unicode ones expand into a really big one with Babel\r\nconst ASCII_LETTER = /[a-z]/;\r\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\r\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\r\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\r\nconst DIGIT = /\\d/;\r\nconst SPACE = /\\s/;\r\n\r\nvar regexp = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tASCII_LETTER: ASCII_LETTER,\r\n\tLETTER: LETTER,\r\n\tEMOJI: EMOJI,\r\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\r\n\tDIGIT: DIGIT,\r\n\tSPACE: SPACE\r\n});\r\n\r\n/**\r\n\tThe scanner provides an interface that takes a string of text as input, and\r\n\toutputs an array of tokens instances that can be used for easy URL parsing.\r\n*/\r\nconst NL = '\\n'; // New line character\r\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\r\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\r\n\r\nlet tlds = null,\r\n  utlds = null; // don't change so only have to be computed once\r\n\r\n/**\r\n * Scanner output token:\r\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\r\n * - `v` is the value of the token (e.g., '123', '\u2764\uFE0F', 'com')\r\n * - `s` is the start index of the token in the original string\r\n * - `e` is the end index of the token in the original string\r\n * @typedef {{t: string, v: string, s: number, e: number}} Token\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ [collection: string]: T[] }} Collections\r\n */\r\n\r\n/**\r\n * Initialize the scanner character-based state machine for the given start\r\n * state\r\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\r\n * item is a length-2 tuple with the first element set to the string scheme, and\r\n * the second element set to `true` if the `://` after the scheme is optional\r\n */\r\nfunction init$2(customSchemes) {\r\n  if (customSchemes === void 0) {\r\n    customSchemes = [];\r\n  }\r\n  // Frequently used states (name argument removed during minification)\r\n  /** @type Collections<string> */\r\n  const groups = {}; // of tokens\r\n  State.groups = groups;\r\n  /** @type State<string> */\r\n  const Start = new State();\r\n  if (tlds == null) {\r\n    tlds = decodeTlds(encodedTlds);\r\n  }\r\n  if (utlds == null) {\r\n    utlds = decodeTlds(encodedUtlds);\r\n  }\r\n\r\n  // States for special URL symbols that accept immediately after start\r\n  tt(Start, \"'\", APOSTROPHE);\r\n  tt(Start, '{', OPENBRACE);\r\n  tt(Start, '[', OPENBRACKET);\r\n  tt(Start, '<', OPENANGLEBRACKET);\r\n  tt(Start, '(', OPENPAREN);\r\n  tt(Start, '}', CLOSEBRACE);\r\n  tt(Start, ']', CLOSEBRACKET);\r\n  tt(Start, '>', CLOSEANGLEBRACKET);\r\n  tt(Start, ')', CLOSEPAREN);\r\n  tt(Start, '&', AMPERSAND);\r\n  tt(Start, '*', ASTERISK);\r\n  tt(Start, '@', AT);\r\n  tt(Start, '`', BACKTICK);\r\n  tt(Start, '^', CARET);\r\n  tt(Start, ':', COLON);\r\n  tt(Start, ',', COMMA);\r\n  tt(Start, '$', DOLLAR);\r\n  tt(Start, '.', DOT);\r\n  tt(Start, '=', EQUALS);\r\n  tt(Start, '!', EXCLAMATION);\r\n  tt(Start, '-', HYPHEN);\r\n  tt(Start, '%', PERCENT);\r\n  tt(Start, '|', PIPE);\r\n  tt(Start, '+', PLUS);\r\n  tt(Start, '#', POUND);\r\n  tt(Start, '?', QUERY);\r\n  tt(Start, '\"', QUOTE);\r\n  tt(Start, '/', SLASH);\r\n  tt(Start, ';', SEMI);\r\n  tt(Start, '~', TILDE);\r\n  tt(Start, '_', UNDERSCORE);\r\n  tt(Start, '\\\\', BACKSLASH);\r\n  const Num = tr(Start, DIGIT, NUM, {\r\n    [numeric]: true\r\n  });\r\n  tr(Num, DIGIT, Num);\r\n\r\n  // State which emits a word token\r\n  const Word = tr(Start, ASCII_LETTER, WORD, {\r\n    [ascii]: true\r\n  });\r\n  tr(Word, ASCII_LETTER, Word);\r\n\r\n  // Same as previous, but specific to non-fsm.ascii alphabet words\r\n  const UWord = tr(Start, LETTER, UWORD, {\r\n    [alpha]: true\r\n  });\r\n  tr(UWord, ASCII_LETTER); // Non-accepting\r\n  tr(UWord, LETTER, UWord);\r\n\r\n  // Whitespace jumps\r\n  // Tokens of only non-newline whitespace are arbitrarily long\r\n  // If any whitespace except newline, more whitespace!\r\n  const Ws = tr(Start, SPACE, WS, {\r\n    [whitespace]: true\r\n  });\r\n  tt(Start, NL, NL$1, {\r\n    [whitespace]: true\r\n  });\r\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\r\n  tr(Ws, SPACE, Ws);\r\n\r\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\r\n  // zero-width joiner is present\r\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\r\n    [emoji]: true\r\n  });\r\n  tr(Emoji, EMOJI, Emoji);\r\n  tt(Emoji, EMOJI_VARIATION, Emoji);\r\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\r\n\r\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\r\n  tr(EmojiJoiner, EMOJI, Emoji);\r\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\r\n\r\n  // Generates states for top-level domains\r\n  // Note that this is most accurate when tlds are in alphabetical order\r\n  const wordjr = [[ASCII_LETTER, Word]];\r\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\r\n  for (let i = 0; i < tlds.length; i++) {\r\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\r\n  }\r\n  for (let i = 0; i < utlds.length; i++) {\r\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\r\n  }\r\n  addToGroups(TLD, {\r\n    tld: true,\r\n    ascii: true\r\n  }, groups);\r\n  addToGroups(UTLD, {\r\n    utld: true,\r\n    alpha: true\r\n  }, groups);\r\n\r\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\r\n  // get added that are also protocols, set the token to be the same as the\r\n  // protocol to ensure parsing works as expected.\r\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\r\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\r\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\r\n  addToGroups(SCHEME, {\r\n    scheme: true,\r\n    ascii: true\r\n  }, groups);\r\n  addToGroups(SLASH_SCHEME, {\r\n    slashscheme: true,\r\n    ascii: true\r\n  }, groups);\r\n\r\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\r\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\r\n  for (let i = 0; i < customSchemes.length; i++) {\r\n    const sch = customSchemes[i][0];\r\n    const optionalSlashSlash = customSchemes[i][1];\r\n    const flags = optionalSlashSlash ? {\r\n      [scheme]: true\r\n    } : {\r\n      [slashscheme]: true\r\n    };\r\n    if (sch.indexOf('-') >= 0) {\r\n      flags[domain] = true;\r\n    } else if (!ASCII_LETTER.test(sch)) {\r\n      flags[numeric] = true; // numbers only\r\n    } else if (DIGIT.test(sch)) {\r\n      flags[asciinumeric] = true;\r\n    } else {\r\n      flags[ascii] = true;\r\n    }\r\n    ts(Start, sch, sch, flags);\r\n  }\r\n\r\n  // Localhost token\r\n  ts(Start, 'localhost', LOCALHOST, {\r\n    ascii: true\r\n  });\r\n\r\n  // Set default transition for start state (some symbol)\r\n  Start.jd = new State(SYM);\r\n  return {\r\n    start: Start,\r\n    tokens: assign({\r\n      groups\r\n    }, tk)\r\n  };\r\n}\r\n\r\n/**\r\n\tGiven a string, returns an array of TOKEN instances representing the\r\n\tcomposition of that string.\r\n\r\n\t@method run\r\n\t@param {State<string>} start scanner starting state\r\n\t@param {string} str input string to scan\r\n\t@return {Token[]} list of tokens, each with a type and value\r\n*/\r\nfunction run$1(start, str) {\r\n  // State machine is not case sensitive, so input is tokenized in lowercased\r\n  // form (still returns regular case). Uses selective `toLowerCase` because\r\n  // lowercasing the entire string causes the length and character position to\r\n  // vary in some non-English strings with V8-based runtimes.\r\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\r\n  const charCount = iterable.length; // <= len if there are emojis, etc\r\n  const tokens = []; // return value\r\n\r\n  // cursor through the string itself, accounting for characters that have\r\n  // width with length 2 such as emojis\r\n  let cursor = 0;\r\n\r\n  // Cursor through the array-representation of the string\r\n  let charCursor = 0;\r\n\r\n  // Tokenize the string\r\n  while (charCursor < charCount) {\r\n    let state = start;\r\n    let nextState = null;\r\n    let tokenLength = 0;\r\n    let latestAccepting = null;\r\n    let sinceAccepts = -1;\r\n    let charsSinceAccepts = -1;\r\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\r\n      state = nextState;\r\n\r\n      // Keep track of the latest accepting state\r\n      if (state.accepts()) {\r\n        sinceAccepts = 0;\r\n        charsSinceAccepts = 0;\r\n        latestAccepting = state;\r\n      } else if (sinceAccepts >= 0) {\r\n        sinceAccepts += iterable[charCursor].length;\r\n        charsSinceAccepts++;\r\n      }\r\n      tokenLength += iterable[charCursor].length;\r\n      cursor += iterable[charCursor].length;\r\n      charCursor++;\r\n    }\r\n\r\n    // Roll back to the latest accepting state\r\n    cursor -= sinceAccepts;\r\n    charCursor -= charsSinceAccepts;\r\n    tokenLength -= sinceAccepts;\r\n\r\n    // No more jumps, just make a new token from the last accepting one\r\n    tokens.push({\r\n      t: latestAccepting.t,\r\n      // token type/name\r\n      v: str.slice(cursor - tokenLength, cursor),\r\n      // string value\r\n      s: cursor - tokenLength,\r\n      // start index\r\n      e: cursor // end index (excluding)\r\n    });\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\n/**\r\n * Convert a String to an Array of characters, taking into account that some\r\n * characters like emojis take up two string indexes.\r\n *\r\n * Adapted from core-js (MIT license)\r\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\r\n *\r\n * @function stringToArray\r\n * @param {string} str\r\n * @returns {string[]}\r\n */\r\nfunction stringToArray(str) {\r\n  const result = [];\r\n  const len = str.length;\r\n  let index = 0;\r\n  while (index < len) {\r\n    let first = str.charCodeAt(index);\r\n    let second;\r\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\r\n    : str.slice(index, index + 2); // two-index characters\r\n    result.push(char);\r\n    index += char.length;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Fast version of ts function for when transition defaults are well known\r\n * @param {State<string>} state\r\n * @param {string} input\r\n * @param {string} t\r\n * @param {string} defaultt\r\n * @param {[RegExp, State<string>][]} jr\r\n * @returns {State<string>}\r\n */\r\nfunction fastts(state, input, t, defaultt, jr) {\r\n  let next;\r\n  const len = input.length;\r\n  for (let i = 0; i < len - 1; i++) {\r\n    const char = input[i];\r\n    if (state.j[char]) {\r\n      next = state.j[char];\r\n    } else {\r\n      next = new State(defaultt);\r\n      next.jr = jr.slice();\r\n      state.j[char] = next;\r\n    }\r\n    state = next;\r\n  }\r\n  next = new State(t);\r\n  next.jr = jr.slice();\r\n  state.j[input[len - 1]] = next;\r\n  return next;\r\n}\r\n\r\n/**\r\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\r\n * into a list of strings.\r\n * @param {str} encoded encoded TLDs string\r\n * @returns {str[]} original TLDs list\r\n */\r\nfunction decodeTlds(encoded) {\r\n  const words = [];\r\n  const stack = [];\r\n  let i = 0;\r\n  let digits = '0123456789';\r\n  while (i < encoded.length) {\r\n    let popDigitCount = 0;\r\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\r\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\r\n    }\r\n\r\n    if (popDigitCount > 0) {\r\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\r\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\r\n        stack.pop();\r\n      }\r\n      i += popDigitCount;\r\n    } else {\r\n      stack.push(encoded[i]); // drop down a level into the trie\r\n      i++;\r\n    }\r\n  }\r\n  return words;\r\n}\r\n\r\n/**\r\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\r\n * and each value is an event handler function.\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\r\n * @typedef {?{ [event: string]: Function }} EventListeners\r\n */\r\n\r\n/**\r\n * All formatted properties required to render a link, including `tagName`,\r\n * `attributes`, `content` and `eventListeners`.\r\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\r\n * eventListeners: EventListeners }} IntermediateRepresentation\r\n */\r\n\r\n/**\r\n * Specify either an object described by the template type `O` or a function.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `O`\r\n * @template O\r\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\r\n */\r\n\r\n/**\r\n * Specify either a function described by template type `F` or an object.\r\n *\r\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\r\n * value should be a function with template type `F` that is called when the\r\n * corresponding link type is encountered.\r\n * @template F\r\n * @typedef {F | { [type: string]: F}} OptFn\r\n */\r\n\r\n/**\r\n * Specify either a value with template type `V`, a function that returns `V` or\r\n * an object where each value resolves to `V`.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `V`\r\n *\r\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\r\n * Each value should either have type `V` or a function that returns V. This\r\n * function similarly takes a string value and a token.\r\n *\r\n * Example valid types for `Opt<string>`:\r\n *\r\n * ```js\r\n * 'hello'\r\n * (value, type, token) => 'world'\r\n * { url: 'hello', email: (value, token) => 'world'}\r\n * ```\r\n * @template V\r\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\r\n */\r\n\r\n/**\r\n * See available options: https://linkify.js.org/docs/options.html\r\n * @typedef {{\r\n * \tdefaultProtocol?: string,\r\n *  events?: OptObj<EventListeners>,\r\n * \tformat?: Opt<string>,\r\n * \tformatHref?: Opt<string>,\r\n * \tnl2br?: boolean,\r\n * \ttagName?: Opt<any>,\r\n * \ttarget?: Opt<string>,\r\n * \trel?: Opt<string>,\r\n * \tvalidate?: Opt<boolean>,\r\n * \ttruncate?: Opt<number>,\r\n * \tclassName?: Opt<string>,\r\n * \tattributes?: OptObj<({ [attr: string]: any })>,\r\n *  ignoreTags?: string[],\r\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\r\n * }} Opts\r\n */\r\n\r\n/**\r\n * @type Required<Opts>\r\n */\r\nconst defaults = {\r\n  defaultProtocol: 'http',\r\n  events: null,\r\n  format: noop,\r\n  formatHref: noop,\r\n  nl2br: false,\r\n  tagName: 'a',\r\n  target: null,\r\n  rel: null,\r\n  validate: true,\r\n  truncate: Infinity,\r\n  className: null,\r\n  attributes: null,\r\n  ignoreTags: [],\r\n  render: null\r\n};\r\n\r\n/**\r\n * Utility class for linkify interfaces to apply specified\r\n * {@link Opts formatting and rendering options}.\r\n *\r\n * @param {Opts | Options} [opts] Option value overrides.\r\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\r\n *   internal use) default render function that determines how to generate an\r\n *   HTML element based on a link token's derived tagName, attributes and HTML.\r\n *   Similar to render option\r\n */\r\nfunction Options(opts, defaultRender) {\r\n  if (defaultRender === void 0) {\r\n    defaultRender = null;\r\n  }\r\n  let o = assign({}, defaults);\r\n  if (opts) {\r\n    o = assign(o, opts instanceof Options ? opts.o : opts);\r\n  }\r\n\r\n  // Ensure all ignored tags are uppercase\r\n  const ignoredTags = o.ignoreTags;\r\n  const uppercaseIgnoredTags = [];\r\n  for (let i = 0; i < ignoredTags.length; i++) {\r\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\r\n  }\r\n  /** @protected */\r\n  this.o = o;\r\n  if (defaultRender) {\r\n    this.defaultRender = defaultRender;\r\n  }\r\n  this.ignoreTags = uppercaseIgnoredTags;\r\n}\r\nOptions.prototype = {\r\n  o: defaults,\r\n  /**\r\n   * @type string[]\r\n   */\r\n  ignoreTags: [],\r\n  /**\r\n   * @param {IntermediateRepresentation} ir\r\n   * @returns {any}\r\n   */\r\n  defaultRender(ir) {\r\n    return ir;\r\n  },\r\n  /**\r\n   * Returns true or false based on whether a token should be displayed as a\r\n   * link based on the user options.\r\n   * @param {MultiToken} token\r\n   * @returns {boolean}\r\n   */\r\n  check(token) {\r\n    return this.get('validate', token.toString(), token);\r\n  },\r\n  // Private methods\r\n\r\n  /**\r\n   * Resolve an option's value based on the value of the option and the given\r\n   * params. If operator and token are specified and the target option is\r\n   * callable, automatically calls the function with the given argument.\r\n   * @template {keyof Opts} K\r\n   * @param {K} key Name of option to use\r\n   * @param {string} [operator] will be passed to the target option if it's a\r\n   * function. If not specified, RAW function value gets returned\r\n   * @param {MultiToken} [token] The token from linkify.tokenize\r\n   * @returns {Opts[K] | any}\r\n   */\r\n  get(key, operator, token) {\r\n    const isCallable = operator != null;\r\n    let option = this.o[key];\r\n    if (!option) {\r\n      return option;\r\n    }\r\n    if (typeof option === 'object') {\r\n      option = token.t in option ? option[token.t] : defaults[key];\r\n      if (typeof option === 'function' && isCallable) {\r\n        option = option(operator, token);\r\n      }\r\n    } else if (typeof option === 'function' && isCallable) {\r\n      option = option(operator, token.t, token);\r\n    }\r\n    return option;\r\n  },\r\n  /**\r\n   * @template {keyof Opts} L\r\n   * @param {L} key Name of options object to use\r\n   * @param {string} [operator]\r\n   * @param {MultiToken} [token]\r\n   * @returns {Opts[L] | any}\r\n   */\r\n  getObj(key, operator, token) {\r\n    let obj = this.o[key];\r\n    if (typeof obj === 'function' && operator != null) {\r\n      obj = obj(operator, token.t, token);\r\n    }\r\n    return obj;\r\n  },\r\n  /**\r\n   * Convert the given token to a rendered element that may be added to the\r\n   * calling-interface's DOM\r\n   * @param {MultiToken} token Token to render to an HTML element\r\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\r\n   *   Component, etc.\r\n   */\r\n  render(token) {\r\n    const ir = token.render(this); // intermediate representation\r\n    const renderFn = this.get('render', null, token) || this.defaultRender;\r\n    return renderFn(ir, token.t, token);\r\n  }\r\n};\r\nfunction noop(val) {\r\n  return val;\r\n}\r\n\r\nvar options = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tdefaults: defaults,\r\n\tOptions: Options,\r\n\tassign: assign\r\n});\r\n\r\n/******************************************************************************\r\n\tMulti-Tokens\r\n\tTokens composed of arrays of TextTokens\r\n******************************************************************************/\r\n\r\n/**\r\n * @param {string} value\r\n * @param {Token[]} tokens\r\n */\r\nfunction MultiToken(value, tokens) {\r\n  this.t = 'token';\r\n  this.v = value;\r\n  this.tk = tokens;\r\n}\r\n\r\n/**\r\n * Abstract class used for manufacturing tokens of text tokens. That is rather\r\n * than the value for a token being a small string of text, it's value an array\r\n * of text tokens.\r\n *\r\n * Used for grouping together URLs, emails, hashtags, and other potential\r\n * creations.\r\n * @class MultiToken\r\n * @property {string} t\r\n * @property {string} v\r\n * @property {Token[]} tk\r\n * @abstract\r\n */\r\nMultiToken.prototype = {\r\n  isLink: false,\r\n  /**\r\n   * Return the string this token represents.\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return this.v;\r\n  },\r\n  /**\r\n   * What should the value for this token be in the `href` HTML attribute?\r\n   * Returns the `.toString` value by default.\r\n   * @param {string} [scheme]\r\n   * @return {string}\r\n  */\r\n  toHref(scheme) {\r\n    return this.toString();\r\n  },\r\n  /**\r\n   * @param {Options} options Formatting options\r\n   * @returns {string}\r\n   */\r\n  toFormattedString(options) {\r\n    const val = this.toString();\r\n    const truncate = options.get('truncate', val, this);\r\n    const formatted = options.get('format', val, this);\r\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '\u2026' : formatted;\r\n  },\r\n  /**\r\n   *\r\n   * @param {Options} options\r\n   * @returns {string}\r\n   */\r\n  toFormattedHref(options) {\r\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\r\n  },\r\n  /**\r\n   * The start index of this token in the original input string\r\n   * @returns {number}\r\n   */\r\n  startIndex() {\r\n    return this.tk[0].s;\r\n  },\r\n  /**\r\n   * The end index of this token in the original input string (up to this\r\n   * index but not including it)\r\n   * @returns {number}\r\n   */\r\n  endIndex() {\r\n    return this.tk[this.tk.length - 1].e;\r\n  },\r\n  /**\r\n  \tReturns an object  of relevant values for this token, which includes keys\r\n  \t* type - Kind of token ('url', 'email', etc.)\r\n  \t* value - Original text\r\n  \t* href - The value that should be added to the anchor tag's href\r\n  \t\tattribute\r\n  \t\t@method toObject\r\n  \t@param {string} [protocol] `'http'` by default\r\n  */\r\n  toObject(protocol) {\r\n    if (protocol === void 0) {\r\n      protocol = defaults.defaultProtocol;\r\n    }\r\n    return {\r\n      type: this.t,\r\n      value: this.toString(),\r\n      isLink: this.isLink,\r\n      href: this.toHref(protocol),\r\n      start: this.startIndex(),\r\n      end: this.endIndex()\r\n    };\r\n  },\r\n  /**\r\n   *\r\n   * @param {Options} options Formatting option\r\n   */\r\n  toFormattedObject(options) {\r\n    return {\r\n      type: this.t,\r\n      value: this.toFormattedString(options),\r\n      isLink: this.isLink,\r\n      href: this.toFormattedHref(options),\r\n      start: this.startIndex(),\r\n      end: this.endIndex()\r\n    };\r\n  },\r\n  /**\r\n   * Whether this token should be rendered as a link according to the given options\r\n   * @param {Options} options\r\n   * @returns {boolean}\r\n   */\r\n  validate(options) {\r\n    return options.get('validate', this.toString(), this);\r\n  },\r\n  /**\r\n   * Return an object that represents how this link should be rendered.\r\n   * @param {Options} options Formattinng options\r\n   */\r\n  render(options) {\r\n    const token = this;\r\n    const href = this.toHref(options.get('defaultProtocol'));\r\n    const formattedHref = options.get('formatHref', href, this);\r\n    const tagName = options.get('tagName', href, token);\r\n    const content = this.toFormattedString(options);\r\n    const attributes = {};\r\n    const className = options.get('className', href, token);\r\n    const target = options.get('target', href, token);\r\n    const rel = options.get('rel', href, token);\r\n    const attrs = options.getObj('attributes', href, token);\r\n    const eventListeners = options.getObj('events', href, token);\r\n    attributes.href = formattedHref;\r\n    if (className) {\r\n      attributes.class = className;\r\n    }\r\n    if (target) {\r\n      attributes.target = target;\r\n    }\r\n    if (rel) {\r\n      attributes.rel = rel;\r\n    }\r\n    if (attrs) {\r\n      assign(attributes, attrs);\r\n    }\r\n    return {\r\n      tagName,\r\n      attributes,\r\n      content,\r\n      eventListeners\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new token that can be emitted by the parser state machine\r\n * @param {string} type readable type of the token\r\n * @param {object} props properties to assign or override, including isLink = true or false\r\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\r\n */\r\nfunction createTokenClass(type, props) {\r\n  class Token extends MultiToken {\r\n    constructor(value, tokens) {\r\n      super(value, tokens);\r\n      this.t = type;\r\n    }\r\n  }\r\n  for (const p in props) {\r\n    Token.prototype[p] = props[p];\r\n  }\r\n  Token.t = type;\r\n  return Token;\r\n}\r\n\r\n/**\r\n\tRepresents a list of tokens making up a valid email address\r\n*/\r\nconst Email = createTokenClass('email', {\r\n  isLink: true,\r\n  toHref() {\r\n    return 'mailto:' + this.toString();\r\n  }\r\n});\r\n\r\n/**\r\n\tRepresents some plain text\r\n*/\r\nconst Text = createTokenClass('text');\r\n\r\n/**\r\n\tMulti-linebreak token - represents a line break\r\n\t@class Nl\r\n*/\r\nconst Nl = createTokenClass('nl');\r\n\r\n/**\r\n\tRepresents a list of text tokens making up a valid URL\r\n\t@class Url\r\n*/\r\nconst Url = createTokenClass('url', {\r\n  isLink: true,\r\n  /**\r\n  \tLowercases relevant parts of the domain and adds the protocol if\r\n  \trequired. Note that this will not escape unsafe HTML characters in the\r\n  \tURL.\r\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\r\n  \t@return {string} the full href\r\n  */\r\n  toHref(scheme) {\r\n    if (scheme === void 0) {\r\n      scheme = defaults.defaultProtocol;\r\n    }\r\n    // Check if already has a prefix scheme\r\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\r\n  },\r\n  /**\r\n   * Check whether this URL token has a protocol\r\n   * @return {boolean}\r\n   */\r\n  hasProtocol() {\r\n    const tokens = this.tk;\r\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\r\n  }\r\n});\r\n\r\nvar multi = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tMultiToken: MultiToken,\r\n\tBase: MultiToken,\r\n\tcreateTokenClass: createTokenClass,\r\n\tEmail: Email,\r\n\tText: Text,\r\n\tNl: Nl,\r\n\tUrl: Url\r\n});\r\n\r\n/**\r\n\tNot exactly parser, more like the second-stage scanner (although we can\r\n\ttheoretically hotswap the code here with a real parser in the future... but\r\n\tfor a little URL-finding utility abstract syntax trees may be a little\r\n\toverkill).\r\n\r\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\r\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\r\n\treference)\r\n\r\n\t@module linkify\r\n\t@submodule parser\r\n\t@main run\r\n*/\r\nconst makeState = arg => new State(arg);\r\n\r\n/**\r\n * Generate the parser multi token-based state machine\r\n * @param {{ groups: Collections<string> }} tokens\r\n */\r\nfunction init$1(_ref) {\r\n  let {\r\n    groups\r\n  } = _ref;\r\n  // Types of characters the URL can definitely end in\r\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\r\n\r\n  // Types of tokens that can follow a URL and be part of the query string\r\n  // but cannot be the very last characters\r\n  // Characters that cannot appear in the URL at all should be excluded\r\n  const qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];\r\n\r\n  // For addresses without the mailto prefix\r\n  // Tokens allowed in the localpart of the email\r\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\r\n\r\n  // The universal starting state.\r\n  /**\r\n   * @type State<Token>\r\n   */\r\n  const Start = makeState();\r\n  const Localpart = tt(Start, TILDE); // Local part of the email address\r\n  ta(Localpart, localpartAccepting, Localpart);\r\n  ta(Localpart, groups.domain, Localpart);\r\n  const Domain = makeState(),\r\n    Scheme = makeState(),\r\n    SlashScheme = makeState();\r\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\r\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\r\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\r\n\r\n  ta(Domain, localpartAccepting, Localpart);\r\n  ta(Domain, groups.domain, Domain);\r\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\r\n\r\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\r\n\r\n  // Local part of an email address can be e.g. 'http' or 'mailto'\r\n  tt(Scheme, AT, LocalpartAt);\r\n  tt(SlashScheme, AT, LocalpartAt);\r\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\r\n  ta(LocalpartDot, localpartAccepting, Localpart);\r\n  ta(LocalpartDot, groups.domain, Localpart);\r\n  const EmailDomain = makeState();\r\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\r\n  ta(EmailDomain, groups.domain, EmailDomain);\r\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\r\n  ta(EmailDomainDot, groups.domain, EmailDomain);\r\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\r\n  ta(EmailDomainDot, groups.tld, Email$1);\r\n  ta(EmailDomainDot, groups.utld, Email$1);\r\n  tt(LocalpartAt, LOCALHOST, Email$1);\r\n\r\n  // Hyphen can jump back to a domain name\r\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\r\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\r\n  ta(Email$1, groups.domain, EmailDomain);\r\n  tt(Email$1, DOT, EmailDomainDot);\r\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\r\n\r\n  // Final possible email states\r\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\r\n  /*const EmailColonPort = */\r\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner\r\n\r\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\r\n  // (but not TLDs)\r\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\r\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\r\n  ta(DomainHyphen, groups.domain, Domain);\r\n  ta(DomainDot, localpartAccepting, Localpart);\r\n  ta(DomainDot, groups.domain, Domain);\r\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\r\n  ta(DomainDot, groups.tld, DomainDotTld);\r\n  ta(DomainDot, groups.utld, DomainDotTld);\r\n  ta(DomainDotTld, groups.domain, Domain);\r\n  ta(DomainDotTld, localpartAccepting, Localpart);\r\n  tt(DomainDotTld, DOT, DomainDot);\r\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\r\n  tt(DomainDotTld, AT, LocalpartAt);\r\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\r\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\r\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\r\n\r\n  // Long URL with optional port and maybe query string\r\n  const Url$1 = makeState(Url);\r\n\r\n  // URL with extra symbols at the end, followed by an opening bracket\r\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\r\n\r\n  // Query strings\r\n  ta(Url$1, qsAccepting, Url$1);\r\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\r\n  ta(UrlNonaccept, qsAccepting, Url$1);\r\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\r\n\r\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\r\n  // Here works with or without scheme:// prefix\r\n  tt(DomainDotTld, SLASH, Url$1);\r\n  tt(DomainDotTldColonPort, SLASH, Url$1);\r\n\r\n  // Note that domains that begin with schemes are treated slighly differently\r\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\r\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\r\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\r\n\r\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\r\n\r\n  // Scheme states can transition to domain states\r\n  ta(Scheme, groups.domain, Domain);\r\n  tt(Scheme, DOT, DomainDot);\r\n  tt(Scheme, HYPHEN, DomainHyphen);\r\n  ta(SlashScheme, groups.domain, Domain);\r\n  tt(SlashScheme, DOT, DomainDot);\r\n  tt(SlashScheme, HYPHEN, DomainHyphen);\r\n\r\n  // Force URL with scheme prefix followed by anything sane\r\n  ta(SchemeColon, groups.domain, Url$1);\r\n  tt(SchemeColon, SLASH, Url$1);\r\n  ta(UriPrefix, groups.domain, Url$1);\r\n  ta(UriPrefix, qsAccepting, Url$1);\r\n  tt(UriPrefix, SLASH, Url$1);\r\n\r\n  // URL, followed by an opening bracket\r\n  const UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {\r\n  const UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [\r\n  const UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <\r\n  const UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (\r\n\r\n  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);\r\n  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);\r\n  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);\r\n  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);\r\n\r\n  // Closing bracket component. This character WILL be included in the URL\r\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\r\n  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);\r\n  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);\r\n  tt(UrlOpenparen, CLOSEPAREN, Url$1);\r\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\r\n\r\n  // URL that beings with an opening bracket, followed by a symbols.\r\n  // Note that the final state can still be `UrlOpenbrace` (if the URL only\r\n  // has a single opening bracket for some reason).\r\n  const UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it\r\n  const UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it\r\n  const UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it\r\n  const UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it\r\n  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);\r\n  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);\r\n  const UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it\r\n  const UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it\r\n  const UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it\r\n  const UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it\r\n  ta(UrlOpenbrace, qsNonAccepting);\r\n  ta(UrlOpenbracket, qsNonAccepting);\r\n  ta(UrlOpenanglebracket, qsNonAccepting);\r\n  ta(UrlOpenparen, qsNonAccepting);\r\n\r\n  // URL that begins with an opening bracket, followed by some symbols\r\n  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);\r\n  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);\r\n  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);\r\n  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);\r\n  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);\r\n  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);\r\n  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);\r\n  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);\r\n  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);\r\n  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);\r\n  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);\r\n  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);\r\n\r\n  // Close brace/bracket to become regular URL\r\n  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);\r\n  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);\r\n  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);\r\n  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);\r\n  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);\r\n  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);\r\n  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);\r\n  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);\r\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\r\n  tt(Start, NL$1, Nl); // single new line\r\n\r\n  return {\r\n    start: Start,\r\n    tokens: tk\r\n  };\r\n}\r\n\r\n/**\r\n * Run the parser state machine on a list of scanned string-based tokens to\r\n * create a list of multi tokens, each of which represents a URL, email address,\r\n * plain text, etc.\r\n *\r\n * @param {State<MultiToken>} start parser start state\r\n * @param {string} input the original input used to generate the given tokens\r\n * @param {Token[]} tokens list of scanned tokens\r\n * @returns {MultiToken[]}\r\n */\r\nfunction run(start, input, tokens) {\r\n  let len = tokens.length;\r\n  let cursor = 0;\r\n  let multis = [];\r\n  let textTokens = [];\r\n  while (cursor < len) {\r\n    let state = start;\r\n    let secondState = null;\r\n    let nextState = null;\r\n    let multiLength = 0;\r\n    let latestAccepting = null;\r\n    let sinceAccepts = -1;\r\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\r\n      // Starting tokens with nowhere to jump to.\r\n      // Consider these to be just plain text\r\n      textTokens.push(tokens[cursor++]);\r\n    }\r\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\r\n      // Get the next state\r\n      secondState = null;\r\n      state = nextState;\r\n\r\n      // Keep track of the latest accepting state\r\n      if (state.accepts()) {\r\n        sinceAccepts = 0;\r\n        latestAccepting = state;\r\n      } else if (sinceAccepts >= 0) {\r\n        sinceAccepts++;\r\n      }\r\n      cursor++;\r\n      multiLength++;\r\n    }\r\n    if (sinceAccepts < 0) {\r\n      // No accepting state was found, part of a regular text token add\r\n      // the first text token to the text tokens array and try again from\r\n      // the next\r\n      cursor -= multiLength;\r\n      if (cursor < len) {\r\n        textTokens.push(tokens[cursor]);\r\n        cursor++;\r\n      }\r\n    } else {\r\n      // Accepting state!\r\n      // First close off the textTokens (if available)\r\n      if (textTokens.length > 0) {\r\n        multis.push(initMultiToken(Text, input, textTokens));\r\n        textTokens = [];\r\n      }\r\n\r\n      // Roll back to the latest accepting state\r\n      cursor -= sinceAccepts;\r\n      multiLength -= sinceAccepts;\r\n\r\n      // Create a new multitoken\r\n      const Multi = latestAccepting.t;\r\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\r\n      multis.push(initMultiToken(Multi, input, subtokens));\r\n    }\r\n  }\r\n\r\n  // Finally close off the textTokens (if available)\r\n  if (textTokens.length > 0) {\r\n    multis.push(initMultiToken(Text, input, textTokens));\r\n  }\r\n  return multis;\r\n}\r\n\r\n/**\r\n * Utility function for instantiating a new multitoken with all the relevant\r\n * fields during parsing.\r\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\r\n * @param {string} input original input string\r\n * @param {Token[]} tokens consecutive tokens scanned from input string\r\n * @returns {MultiToken}\r\n */\r\nfunction initMultiToken(Multi, input, tokens) {\r\n  const startIdx = tokens[0].s;\r\n  const endIdx = tokens[tokens.length - 1].e;\r\n  const value = input.slice(startIdx, endIdx);\r\n  return new Multi(value, tokens);\r\n}\r\n\r\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\r\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\r\n\r\n// Side-effect initialization state\r\nconst INIT = {\r\n  scanner: null,\r\n  parser: null,\r\n  tokenQueue: [],\r\n  pluginQueue: [],\r\n  customSchemes: [],\r\n  initialized: false\r\n};\r\n\r\n/**\r\n * @typedef {{\r\n * \tstart: State<string>,\r\n * \ttokens: { groups: Collections<string> } & typeof tk\r\n * }} ScannerInit\r\n */\r\n\r\n/**\r\n * @typedef {{\r\n * \tstart: State<MultiToken>,\r\n * \ttokens: typeof multi\r\n * }} ParserInit\r\n */\r\n\r\n/**\r\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\r\n */\r\n\r\n/**\r\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\r\n */\r\n\r\n/**\r\n * De-register all plugins and reset the internal state-machine. Used for\r\n * testing; not required in practice.\r\n * @private\r\n */\r\nfunction reset() {\r\n  State.groups = {};\r\n  INIT.scanner = null;\r\n  INIT.parser = null;\r\n  INIT.tokenQueue = [];\r\n  INIT.pluginQueue = [];\r\n  INIT.customSchemes = [];\r\n  INIT.initialized = false;\r\n}\r\n\r\n/**\r\n * Register a token plugin to allow the scanner to recognize additional token\r\n * types before the parser state machine is constructed from the results.\r\n * @param {string} name of plugin to register\r\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\r\n * and available scanner tokens and collections and extends the state machine to\r\n * recognize additional tokens or groups.\r\n */\r\nfunction registerTokenPlugin(name, plugin) {\r\n  if (typeof plugin !== 'function') {\r\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\r\n  }\r\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\r\n    if (name === INIT.tokenQueue[i][0]) {\r\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\r\n      INIT.tokenQueue[i] = [name, plugin];\r\n      return;\r\n    }\r\n  }\r\n  INIT.tokenQueue.push([name, plugin]);\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Register a linkify plugin\r\n * @param {string} name of plugin to register\r\n * @param {Plugin} plugin function that accepts the parser state machine and\r\n * extends the parser to recognize additional link types\r\n */\r\nfunction registerPlugin(name, plugin) {\r\n  if (typeof plugin !== 'function') {\r\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\r\n  }\r\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\r\n    if (name === INIT.pluginQueue[i][0]) {\r\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\r\n      INIT.pluginQueue[i] = [name, plugin];\r\n      return;\r\n    }\r\n  }\r\n  INIT.pluginQueue.push([name, plugin]);\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Detect URLs with the following additional protocol. Anything with format\r\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\r\n * `true`, anything with format \"protocol:...\" will be considered a link.\r\n * @param {string} protocol\r\n * @param {boolean} [optionalSlashSlash]\r\n */\r\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\r\n  if (optionalSlashSlash === void 0) {\r\n    optionalSlashSlash = false;\r\n  }\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\r\n  }\r\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\r\n    throw new Error('linkifyjs: incorrect scheme format.\\n 1. Must only contain digits, lowercase ASCII letters or \"-\"\\n 2. Cannot start or end with \"-\"\\n 3. \"-\" cannot repeat');\r\n  }\r\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\r\n}\r\n\r\n/**\r\n * Initialize the linkify state machine. Called automatically the first time\r\n * linkify is called on a string, but may be called manually as well.\r\n */\r\nfunction init() {\r\n  // Initialize scanner state machine and plugins\r\n  INIT.scanner = init$2(INIT.customSchemes);\r\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\r\n    INIT.tokenQueue[i][1]({\r\n      scanner: INIT.scanner\r\n    });\r\n  }\r\n\r\n  // Initialize parser state machine and plugins\r\n  INIT.parser = init$1(INIT.scanner.tokens);\r\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\r\n    INIT.pluginQueue[i][1]({\r\n      scanner: INIT.scanner,\r\n      parser: INIT.parser\r\n    });\r\n  }\r\n  INIT.initialized = true;\r\n}\r\n\r\n/**\r\n * Parse a string into tokens that represent linkable and non-linkable sub-components\r\n * @param {string} str\r\n * @return {MultiToken[]} tokens\r\n */\r\nfunction tokenize(str) {\r\n  if (!INIT.initialized) {\r\n    init();\r\n  }\r\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\r\n}\r\n\r\n/**\r\n * Find a list of linkable items in the given string.\r\n * @param {string} str string to find links in\r\n * @param {string | Opts} [type] either formatting options or specific type of\r\n * links to find, e.g., 'url' or 'email'\r\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\r\n * if opts already provided in `type` argument\r\n*/\r\nfunction find(str, type, opts) {\r\n  if (type === void 0) {\r\n    type = null;\r\n  }\r\n  if (opts === void 0) {\r\n    opts = null;\r\n  }\r\n  if (type && typeof type === 'object') {\r\n    if (opts) {\r\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\r\n    }\r\n    opts = type;\r\n    type = null;\r\n  }\r\n  const options = new Options(opts);\r\n  const tokens = tokenize(str);\r\n  const filtered = [];\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const token = tokens[i];\r\n    if (token.isLink && (!type || token.t === type)) {\r\n      filtered.push(token.toFormattedObject(options));\r\n    }\r\n  }\r\n  return filtered;\r\n}\r\n\r\n/**\r\n * Is the given string valid linkable text of some sort. Note that this does not\r\n * trim the text for you.\r\n *\r\n * Optionally pass in a second `type` param, which is the type of link to test\r\n * for.\r\n *\r\n * For example,\r\n *\r\n *     linkify.test(str, 'email');\r\n *\r\n * Returns `true` if str is a valid email.\r\n * @param {string} str string to test for links\r\n * @param {string} [type] optional specific link type to look for\r\n * @returns boolean true/false\r\n */\r\nfunction test(str, type) {\r\n  if (type === void 0) {\r\n    type = null;\r\n  }\r\n  const tokens = tokenize(str);\r\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\r\n}\r\n\r\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, tokenize };\r\n", "import { Options, tokenize } from 'linkifyjs';\r\n\r\n/**\r\n\tConvert strings of text into linkable HTML text\r\n*/\r\nfunction escapeText(text) {\r\n  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\nfunction escapeAttr(href) {\r\n  return href.replace(/\"/g, '&quot;');\r\n}\r\nfunction attributesToString(attributes) {\r\n  const result = [];\r\n  for (const attr in attributes) {\r\n    let val = attributes[attr] + '';\r\n    result.push(`${attr}=\"${escapeAttr(val)}\"`);\r\n  }\r\n  return result.join(' ');\r\n}\r\nfunction defaultRender(_ref) {\r\n  let {\r\n    tagName,\r\n    attributes,\r\n    content\r\n  } = _ref;\r\n  return `<${tagName} ${attributesToString(attributes)}>${escapeText(content)}</${tagName}>`;\r\n}\r\n\r\n/**\r\n * Convert a plan text string to an HTML string with links. Expects that the\r\n * given strings does not contain any HTML entities. Use the linkify-html\r\n * interface if you need to parse HTML entities.\r\n *\r\n * @param {string} str string to linkify\r\n * @param {import('linkifyjs').Opts} [opts] overridable options\r\n * @returns {string}\r\n */\r\nfunction linkifyStr(str, opts) {\r\n  if (opts === void 0) {\r\n    opts = {};\r\n  }\r\n  opts = new Options(opts, defaultRender);\r\n  const tokens = tokenize(str);\r\n  const result = [];\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const token = tokens[i];\r\n    if (token.t === 'nl' && opts.get('nl2br')) {\r\n      result.push('<br>\\n');\r\n    } else if (!token.isLink || !opts.check(token)) {\r\n      result.push(escapeText(token.toString()));\r\n    } else {\r\n      result.push(opts.render(token));\r\n    }\r\n  }\r\n  return result.join('');\r\n}\r\nif (!String.prototype.linkify) {\r\n  Object.defineProperty(String.prototype, 'linkify', {\r\n    writable: false,\r\n    value: function linkify(options) {\r\n      return linkifyStr(this, options);\r\n    }\r\n  });\r\n}\r\n\r\nexport { linkifyStr as default };\r\n"],
  "mappings": ";;;AAGA,IAAM,cAAc;AAEpB,IAAM,eAAe;AASrB,IAAM,SAAS,CAAC,QAAQ,eAAe;AACrC,aAAW,OAAO,YAAY;AAC5B,WAAO,OAAO,WAAW;AAAA,EAC3B;AACA,SAAO;AACT;AAgBA,IAAM,UAAU;AAChB,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,eAAe;AACrB,IAAM,eAAe;AACrB,IAAM,SAAS;AACf,IAAM,QAAQ;AACd,IAAM,SAAS;AACf,IAAM,cAAc;AACpB,IAAM,aAAa;AAQnB,SAAS,cAAc,MAAM,QAAQ;AACnC,MAAI,EAAE,QAAQ,SAAS;AACrB,WAAO,QAAQ,CAAC;AAAA,EAClB;AACA,SAAO,OAAO;AAChB;AAQA,SAAS,YAAY,GAAG,OAAO,QAAQ;AACrC,MAAI,MAAM,UAAU;AAClB,UAAM,gBAAgB;AACtB,UAAM,gBAAgB;AAAA,EACxB;AACA,MAAI,MAAM,QAAQ;AAChB,UAAM,gBAAgB;AACtB,UAAM,SAAS;AAAA,EACjB;AACA,MAAI,MAAM,eAAe;AACvB,UAAM,gBAAgB;AAAA,EACxB;AACA,MAAI,MAAM,QAAQ;AAChB,UAAM,gBAAgB;AAAA,EACxB;AACA,MAAI,MAAM,eAAe;AACvB,UAAM,UAAU;AAAA,EAClB;AACA,MAAI,MAAM,QAAQ;AAChB,UAAM,UAAU;AAAA,EAClB;AACA,aAAW,KAAK,OAAO;AACrB,UAAM,QAAQ,cAAc,GAAG,MAAM;AACrC,QAAI,MAAM,QAAQ,CAAC,IAAI,GAAG;AACxB,YAAM,KAAK,CAAC;AAAA,IACd;AAAA,EACF;AACF;AAQA,SAAS,cAAc,GAAG,QAAQ;AAChC,QAAM,SAAS,CAAC;AAChB,aAAW,KAAK,QAAQ;AACtB,QAAI,OAAO,GAAG,QAAQ,CAAC,KAAK,GAAG;AAC7B,aAAO,KAAK;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;AAoBA,SAAS,MAAM,OAAO;AACpB,MAAI,UAAU,QAAQ;AACpB,YAAQ;AAAA,EACV;AAGA,OAAK,IAAI,CAAC;AAGV,OAAK,KAAK,CAAC;AAEX,OAAK,KAAK;AAEV,OAAK,IAAI;AACX;AAMA,MAAM,SAAS,CAAC;AAChB,MAAM,YAAY;AAAA,EAChB,UAAU;AACR,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA,EAOA,GAAG,OAAO;AACR,UAAM,QAAQ;AACd,UAAM,YAAY,MAAM,EAAE;AAC1B,QAAI,WAAW;AACb,aAAO;AAAA,IACT;AACA,aAAS,IAAI,GAAG,IAAI,MAAM,GAAG,QAAQ,KAAK;AACxC,YAAM,QAAQ,MAAM,GAAG,GAAG;AAC1B,YAAMA,aAAY,MAAM,GAAG,GAAG;AAC9B,UAAIA,cAAa,MAAM,KAAK,KAAK,GAAG;AAClC,eAAOA;AAAA,MACT;AAAA,IACF;AAEA,WAAO,MAAM;AAAA,EACf;AAAA,EAQA,IAAI,OAAO,WAAW;AACpB,QAAI,cAAc,QAAQ;AACxB,kBAAY;AAAA,IACd;AACA,WAAO,YAAY,SAAS,KAAK,IAAI,CAAC,CAAC,KAAK,GAAG,KAAK;AAAA,EACtD;AAAA,EASA,GAAG,QAAQ,MAAM,OAAO,QAAQ;AAC9B,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,WAAK,GAAG,OAAO,IAAI,MAAM,OAAO,MAAM;AAAA,IACxC;AAAA,EACF;AAAA,EAUA,GAAGC,SAAQ,MAAM,OAAO,QAAQ;AAC9B,aAAS,UAAU,MAAM;AACzB,QAAI;AACJ,QAAI,QAAQ,KAAK,GAAG;AAClB,kBAAY;AAAA,IACd,OAAO;AAEL,kBAAY,IAAI,MAAM,IAAI;AAC1B,UAAI,SAAS,QAAQ;AACnB,oBAAY,MAAM,OAAO,MAAM;AAAA,MACjC;AAAA,IACF;AACA,SAAK,GAAG,KAAK,CAACA,SAAQ,SAAS,CAAC;AAChC,WAAO;AAAA,EACT;AAAA,EAWA,GAAG,OAAO,MAAM,OAAO,QAAQ;AAC7B,QAAI,QAAQ;AACZ,UAAM,MAAM,MAAM;AAClB,QAAI,CAAC,KAAK;AACR,aAAO;AAAA,IACT;AACA,aAAS,IAAI,GAAG,IAAI,MAAM,GAAG,KAAK;AAChC,cAAQ,MAAM,GAAG,MAAM,EAAE;AAAA,IAC3B;AACA,WAAO,MAAM,GAAG,MAAM,MAAM,IAAI,MAAM,OAAO,MAAM;AAAA,EACrD;AAAA,EA2BA,GAAG,OAAO,MAAM,OAAO,QAAQ;AAC7B,aAAS,UAAU,MAAM;AACzB,UAAM,QAAQ;AAGd,QAAI,QAAQ,KAAK,GAAG;AAClB,YAAM,EAAE,SAAS;AACjB,aAAO;AAAA,IACT;AACA,UAAM,IAAI;AAIV,QAAI,WACF,gBAAgB,MAAM,GAAG,KAAK;AAChC,QAAI,eAAe;AACjB,kBAAY,IAAI,MAAM;AACtB,aAAO,UAAU,GAAG,cAAc,CAAC;AACnC,gBAAU,GAAG,KAAK,MAAM,UAAU,IAAI,cAAc,EAAE;AACtD,gBAAU,KAAK,cAAc;AAC7B,gBAAU,IAAI,cAAc;AAAA,IAC9B,OAAO;AACL,kBAAY,IAAI,MAAM;AAAA,IACxB;AACA,QAAI,GAAG;AAEL,UAAI,QAAQ;AACV,YAAI,UAAU,KAAK,OAAO,UAAU,MAAM,UAAU;AAClD,gBAAM,WAAW,OAAO,cAAc,UAAU,GAAG,MAAM,GAAG,KAAK;AACjE,sBAAY,GAAG,UAAU,MAAM;AAAA,QACjC,WAAW,OAAO;AAChB,sBAAY,GAAG,OAAO,MAAM;AAAA,QAC9B;AAAA,MACF;AACA,gBAAU,IAAI;AAAA,IAChB;AAEA,UAAM,EAAE,SAAS;AACjB,WAAO;AAAA,EACT;AACF;AAWA,IAAM,KAAK,CAAC,OAAO,OAAO,MAAM,OAAO,WAAW,MAAM,GAAG,OAAO,MAAM,OAAO,MAAM;AAUrF,IAAM,KAAK,CAAC,OAAOA,SAAQ,MAAM,OAAO,WAAW,MAAM,GAAGA,SAAQ,MAAM,OAAO,MAAM;AAUvF,IAAM,KAAK,CAAC,OAAO,OAAO,MAAM,OAAO,WAAW,MAAM,GAAG,OAAO,MAAM,OAAO,MAAM;AAUrF,IAAM,KAAK,CAAC,OAAO,OAAO,MAAM,OAAO,WAAW,MAAM,GAAG,OAAO,MAAM,OAAO,MAAM;AAQrF,IAAM,OAAO;AACb,IAAM,QAAQ;AAGd,IAAM,YAAY;AAGlB,IAAM,MAAM;AAGZ,IAAM,OAAO;AAKb,IAAM,SAAS;AAKf,IAAM,eAAe;AAGrB,IAAM,MAAM;AAGZ,IAAM,KAAK;AAGX,IAAM,OAAO;AAGb,IAAM,YAAY;AAClB,IAAM,cAAc;AACpB,IAAM,mBAAmB;AACzB,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,eAAe;AACrB,IAAM,oBAAoB;AAC1B,IAAM,aAAa;AAGnB,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,WAAW;AACjB,IAAM,KAAK;AACX,IAAM,YAAY;AAClB,IAAM,WAAW;AACjB,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,SAAS;AACf,IAAM,MAAM;AACZ,IAAM,SAAS;AACf,IAAM,cAAc;AACpB,IAAM,SAAS;AACf,IAAM,UAAU;AAChB,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,QAAQ;AAEd,IAAM,OAAO;AACb,IAAM,QAAQ;AACd,IAAM,QAAQ;AACd,IAAM,aAAa;AAGnB,IAAM,UAAU;AAGhB,IAAM,MAAM;AAEZ,IAAI,KAAkB,OAAO,OAAO;AAAA,EACnC,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,IAAI;AAAA,EACJ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP;AACD,CAAC;AAGD,IAAM,eAAe;AACrB,IAAM,SAAS;AACf,IAAM,QAAQ;AACd,IAAM,oBAAoB;AAC1B,IAAM,QAAQ;AACd,IAAM,QAAQ;AAEd,IAAI,SAAsB,OAAO,OAAO;AAAA,EACvC,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA,iBAAiB;AAAA,EACjB;AAAA,EACA;AACD,CAAC;AAMD,IAAM,KAAK;AACX,IAAM,kBAAkB;AACxB,IAAM,eAAe;AAErB,IAAI,OAAO;AAAX,IACE,QAAQ;AAuBV,SAAS,OAAO,eAAe;AAC7B,MAAI,kBAAkB,QAAQ;AAC5B,oBAAgB,CAAC;AAAA,EACnB;AAGA,QAAM,SAAS,CAAC;AAChB,QAAM,SAAS;AAEf,QAAM,QAAQ,IAAI,MAAM;AACxB,MAAI,QAAQ,MAAM;AAChB,WAAO,WAAW,WAAW;AAAA,EAC/B;AACA,MAAI,SAAS,MAAM;AACjB,YAAQ,WAAW,YAAY;AAAA,EACjC;AAGA,KAAG,OAAO,KAAK,UAAU;AACzB,KAAG,OAAO,KAAK,SAAS;AACxB,KAAG,OAAO,KAAK,WAAW;AAC1B,KAAG,OAAO,KAAK,gBAAgB;AAC/B,KAAG,OAAO,KAAK,SAAS;AACxB,KAAG,OAAO,KAAK,UAAU;AACzB,KAAG,OAAO,KAAK,YAAY;AAC3B,KAAG,OAAO,KAAK,iBAAiB;AAChC,KAAG,OAAO,KAAK,UAAU;AACzB,KAAG,OAAO,KAAK,SAAS;AACxB,KAAG,OAAO,KAAK,QAAQ;AACvB,KAAG,OAAO,KAAK,EAAE;AACjB,KAAG,OAAO,KAAK,QAAQ;AACvB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,MAAM;AACrB,KAAG,OAAO,KAAK,GAAG;AAClB,KAAG,OAAO,KAAK,MAAM;AACrB,KAAG,OAAO,KAAK,WAAW;AAC1B,KAAG,OAAO,KAAK,MAAM;AACrB,KAAG,OAAO,KAAK,OAAO;AACtB,KAAG,OAAO,KAAK,IAAI;AACnB,KAAG,OAAO,KAAK,IAAI;AACnB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,IAAI;AACnB,KAAG,OAAO,KAAK,KAAK;AACpB,KAAG,OAAO,KAAK,UAAU;AACzB,KAAG,OAAO,MAAM,SAAS;AACzB,QAAM,MAAM,GAAG,OAAO,OAAO,KAAK;AAAA,IAChC,CAAC,UAAU;AAAA,EACb,CAAC;AACD,KAAG,KAAK,OAAO,GAAG;AAGlB,QAAM,OAAO,GAAG,OAAO,cAAc,MAAM;AAAA,IACzC,CAAC,QAAQ;AAAA,EACX,CAAC;AACD,KAAG,MAAM,cAAc,IAAI;AAG3B,QAAM,QAAQ,GAAG,OAAO,QAAQ,OAAO;AAAA,IACrC,CAAC,QAAQ;AAAA,EACX,CAAC;AACD,KAAG,OAAO,YAAY;AACtB,KAAG,OAAO,QAAQ,KAAK;AAKvB,QAAM,KAAK,GAAG,OAAO,OAAO,IAAI;AAAA,IAC9B,CAAC,aAAa;AAAA,EAChB,CAAC;AACD,KAAG,OAAO,IAAI,MAAM;AAAA,IAClB,CAAC,aAAa;AAAA,EAChB,CAAC;AACD,KAAG,IAAI,EAAE;AACT,KAAG,IAAI,OAAO,EAAE;AAIhB,QAAM,QAAQ,GAAG,OAAO,OAAO,SAAS;AAAA,IACtC,CAAC,QAAQ;AAAA,EACX,CAAC;AACD,KAAG,OAAO,OAAO,KAAK;AACtB,KAAG,OAAO,iBAAiB,KAAK;AAGhC,QAAM,cAAc,GAAG,OAAO,YAAY;AAC1C,KAAG,aAAa,OAAO,KAAK;AAK5B,QAAM,SAAS,CAAC,CAAC,cAAc,IAAI,CAAC;AACpC,QAAM,UAAU,CAAC,CAAC,cAAc,IAAI,GAAG,CAAC,QAAQ,KAAK,CAAC;AACtD,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,WAAO,OAAO,KAAK,IAAI,KAAK,MAAM,MAAM;AAAA,EAC1C;AACA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,WAAO,OAAO,MAAM,IAAI,MAAM,OAAO,OAAO;AAAA,EAC9C;AACA,cAAY,KAAK;AAAA,IACf,KAAK;AAAA,IACL,OAAO;AAAA,EACT,GAAG,MAAM;AACT,cAAY,MAAM;AAAA,IAChB,MAAM;AAAA,IACN,OAAO;AAAA,EACT,GAAG,MAAM;AAKT,SAAO,OAAO,QAAQ,QAAQ,MAAM,MAAM;AAC1C,SAAO,OAAO,UAAU,QAAQ,MAAM,MAAM;AAC5C,SAAO,OAAO,QAAQ,cAAc,MAAM,MAAM;AAChD,SAAO,OAAO,SAAS,cAAc,MAAM,MAAM;AACjD,SAAO,OAAO,OAAO,cAAc,MAAM,MAAM;AAC/C,SAAO,OAAO,QAAQ,cAAc,MAAM,MAAM;AAChD,cAAY,QAAQ;AAAA,IAClB,QAAQ;AAAA,IACR,OAAO;AAAA,EACT,GAAG,MAAM;AACT,cAAY,cAAc;AAAA,IACxB,aAAa;AAAA,IACb,OAAO;AAAA,EACT,GAAG,MAAM;AAGT,kBAAgB,cAAc,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE,KAAK,IAAI,EAAE;AACjE,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,UAAM,MAAM,cAAc,GAAG;AAC7B,UAAM,qBAAqB,cAAc,GAAG;AAC5C,UAAM,QAAQ,qBAAqB;AAAA,MACjC,CAAC,SAAS;AAAA,IACZ,IAAI;AAAA,MACF,CAAC,cAAc;AAAA,IACjB;AACA,QAAI,IAAI,QAAQ,GAAG,KAAK,GAAG;AACzB,YAAM,UAAU;AAAA,IAClB,WAAW,CAAC,aAAa,KAAK,GAAG,GAAG;AAClC,YAAM,WAAW;AAAA,IACnB,WAAW,MAAM,KAAK,GAAG,GAAG;AAC1B,YAAM,gBAAgB;AAAA,IACxB,OAAO;AACL,YAAM,SAAS;AAAA,IACjB;AACA,OAAG,OAAO,KAAK,KAAK,KAAK;AAAA,EAC3B;AAGA,KAAG,OAAO,aAAa,WAAW;AAAA,IAChC,OAAO;AAAA,EACT,CAAC;AAGD,QAAM,KAAK,IAAI,MAAM,GAAG;AACxB,SAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ,OAAO;AAAA,MACb;AAAA,IACF,GAAG,EAAE;AAAA,EACP;AACF;AAWA,SAAS,MAAM,OAAO,KAAK;AAKzB,QAAM,WAAW,cAAc,IAAI,QAAQ,UAAU,OAAK,EAAE,YAAY,CAAC,CAAC;AAC1E,QAAM,YAAY,SAAS;AAC3B,QAAM,SAAS,CAAC;AAIhB,MAAI,SAAS;AAGb,MAAI,aAAa;AAGjB,SAAO,aAAa,WAAW;AAC7B,QAAI,QAAQ;AACZ,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,kBAAkB;AACtB,QAAI,eAAe;AACnB,QAAI,oBAAoB;AACxB,WAAO,aAAa,cAAc,YAAY,MAAM,GAAG,SAAS,WAAW,IAAI;AAC7E,cAAQ;AAGR,UAAI,MAAM,QAAQ,GAAG;AACnB,uBAAe;AACf,4BAAoB;AACpB,0BAAkB;AAAA,MACpB,WAAW,gBAAgB,GAAG;AAC5B,wBAAgB,SAAS,YAAY;AACrC;AAAA,MACF;AACA,qBAAe,SAAS,YAAY;AACpC,gBAAU,SAAS,YAAY;AAC/B;AAAA,IACF;AAGA,cAAU;AACV,kBAAc;AACd,mBAAe;AAGf,WAAO,KAAK;AAAA,MACV,GAAG,gBAAgB;AAAA,MAEnB,GAAG,IAAI,MAAM,SAAS,aAAa,MAAM;AAAA,MAEzC,GAAG,SAAS;AAAA,MAEZ,GAAG;AAAA,IACL,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAaA,SAAS,cAAc,KAAK;AAC1B,QAAM,SAAS,CAAC;AAChB,QAAM,MAAM,IAAI;AAChB,MAAI,QAAQ;AACZ,SAAO,QAAQ,KAAK;AAClB,QAAI,QAAQ,IAAI,WAAW,KAAK;AAChC,QAAI;AACJ,QAAI,OAAO,QAAQ,SAAU,QAAQ,SAAU,QAAQ,MAAM,QAAQ,SAAS,IAAI,WAAW,QAAQ,CAAC,KAAK,SAAU,SAAS,QAAS,IAAI,SACzI,IAAI,MAAM,OAAO,QAAQ,CAAC;AAC5B,WAAO,KAAK,IAAI;AAChB,aAAS,KAAK;AAAA,EAChB;AACA,SAAO;AACT;AAWA,SAAS,OAAO,OAAO,OAAO,GAAG,UAAU,IAAI;AAC7C,MAAI;AACJ,QAAM,MAAM,MAAM;AAClB,WAAS,IAAI,GAAG,IAAI,MAAM,GAAG,KAAK;AAChC,UAAM,OAAO,MAAM;AACnB,QAAI,MAAM,EAAE,OAAO;AACjB,aAAO,MAAM,EAAE;AAAA,IACjB,OAAO;AACL,aAAO,IAAI,MAAM,QAAQ;AACzB,WAAK,KAAK,GAAG,MAAM;AACnB,YAAM,EAAE,QAAQ;AAAA,IAClB;AACA,YAAQ;AAAA,EACV;AACA,SAAO,IAAI,MAAM,CAAC;AAClB,OAAK,KAAK,GAAG,MAAM;AACnB,QAAM,EAAE,MAAM,MAAM,MAAM;AAC1B,SAAO;AACT;AAQA,SAAS,WAAW,SAAS;AAC3B,QAAM,QAAQ,CAAC;AACf,QAAM,QAAQ,CAAC;AACf,MAAI,IAAI;AACR,MAAI,SAAS;AACb,SAAO,IAAI,QAAQ,QAAQ;AACzB,QAAI,gBAAgB;AACpB,WAAO,OAAO,QAAQ,QAAQ,IAAI,cAAc,KAAK,GAAG;AACtD;AAAA,IACF;AAEA,QAAI,gBAAgB,GAAG;AACrB,YAAM,KAAK,MAAM,KAAK,EAAE,CAAC;AACzB,eAAS,WAAW,SAAS,QAAQ,UAAU,GAAG,IAAI,aAAa,GAAG,EAAE,GAAG,WAAW,GAAG,YAAY;AACnG,cAAM,IAAI;AAAA,MACZ;AACA,WAAK;AAAA,IACP,OAAO;AACL,YAAM,KAAK,QAAQ,EAAE;AACrB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAmFA,IAAM,WAAW;AAAA,EACf,iBAAiB;AAAA,EACjB,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,OAAO;AAAA,EACP,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,UAAU;AAAA,EACV,UAAU;AAAA,EACV,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,YAAY,CAAC;AAAA,EACb,QAAQ;AACV;AAYA,SAAS,QAAQ,MAAMC,gBAAe;AACpC,MAAIA,mBAAkB,QAAQ;AAC5B,IAAAA,iBAAgB;AAAA,EAClB;AACA,MAAI,IAAI,OAAO,CAAC,GAAG,QAAQ;AAC3B,MAAI,MAAM;AACR,QAAI,OAAO,GAAG,gBAAgB,UAAU,KAAK,IAAI,IAAI;AAAA,EACvD;AAGA,QAAM,cAAc,EAAE;AACtB,QAAM,uBAAuB,CAAC;AAC9B,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,yBAAqB,KAAK,YAAY,GAAG,YAAY,CAAC;AAAA,EACxD;AAEA,OAAK,IAAI;AACT,MAAIA,gBAAe;AACjB,SAAK,gBAAgBA;AAAA,EACvB;AACA,OAAK,aAAa;AACpB;AACA,QAAQ,YAAY;AAAA,EAClB,GAAG;AAAA,EAIH,YAAY,CAAC;AAAA,EAKb,cAAc,IAAI;AAChB,WAAO;AAAA,EACT;AAAA,EAOA,MAAM,OAAO;AACX,WAAO,KAAK,IAAI,YAAY,MAAM,SAAS,GAAG,KAAK;AAAA,EACrD;AAAA,EAcA,IAAI,KAAK,UAAU,OAAO;AACxB,UAAM,aAAa,YAAY;AAC/B,QAAI,SAAS,KAAK,EAAE;AACpB,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AACA,QAAI,OAAO,WAAW,UAAU;AAC9B,eAAS,MAAM,KAAK,SAAS,OAAO,MAAM,KAAK,SAAS;AACxD,UAAI,OAAO,WAAW,cAAc,YAAY;AAC9C,iBAAS,OAAO,UAAU,KAAK;AAAA,MACjC;AAAA,IACF,WAAW,OAAO,WAAW,cAAc,YAAY;AACrD,eAAS,OAAO,UAAU,MAAM,GAAG,KAAK;AAAA,IAC1C;AACA,WAAO;AAAA,EACT;AAAA,EAQA,OAAO,KAAK,UAAU,OAAO;AAC3B,QAAI,MAAM,KAAK,EAAE;AACjB,QAAI,OAAO,QAAQ,cAAc,YAAY,MAAM;AACjD,YAAM,IAAI,UAAU,MAAM,GAAG,KAAK;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAAA,EAQA,OAAO,OAAO;AACZ,UAAM,KAAK,MAAM,OAAO,IAAI;AAC5B,UAAM,WAAW,KAAK,IAAI,UAAU,MAAM,KAAK,KAAK,KAAK;AACzD,WAAO,SAAS,IAAI,MAAM,GAAG,KAAK;AAAA,EACpC;AACF;AACA,SAAS,KAAK,KAAK;AACjB,SAAO;AACT;AAEA,IAAI,UAAuB,OAAO,OAAO;AAAA,EACxC,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA;AACD,CAAC;AAWD,SAAS,WAAW,OAAO,QAAQ;AACjC,OAAK,IAAI;AACT,OAAK,IAAI;AACT,OAAK,KAAK;AACZ;AAeA,WAAW,YAAY;AAAA,EACrB,QAAQ;AAAA,EAKR,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA,EAOA,OAAOC,SAAQ;AACb,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAKA,kBAAkBC,UAAS;AACzB,UAAM,MAAM,KAAK,SAAS;AAC1B,UAAM,WAAWA,SAAQ,IAAI,YAAY,KAAK,IAAI;AAClD,UAAM,YAAYA,SAAQ,IAAI,UAAU,KAAK,IAAI;AACjD,WAAO,YAAY,UAAU,SAAS,WAAW,UAAU,UAAU,GAAG,QAAQ,IAAI,WAAM;AAAA,EAC5F;AAAA,EAMA,gBAAgBA,UAAS;AACvB,WAAOA,SAAQ,IAAI,cAAc,KAAK,OAAOA,SAAQ,IAAI,iBAAiB,CAAC,GAAG,IAAI;AAAA,EACpF;AAAA,EAKA,aAAa;AACX,WAAO,KAAK,GAAG,GAAG;AAAA,EACpB;AAAA,EAMA,WAAW;AACT,WAAO,KAAK,GAAG,KAAK,GAAG,SAAS,GAAG;AAAA,EACrC;AAAA,EAUA,SAAS,UAAU;AACjB,QAAI,aAAa,QAAQ;AACvB,iBAAW,SAAS;AAAA,IACtB;AACA,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,OAAO,KAAK,SAAS;AAAA,MACrB,QAAQ,KAAK;AAAA,MACb,MAAM,KAAK,OAAO,QAAQ;AAAA,MAC1B,OAAO,KAAK,WAAW;AAAA,MACvB,KAAK,KAAK,SAAS;AAAA,IACrB;AAAA,EACF;AAAA,EAKA,kBAAkBA,UAAS;AACzB,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,OAAO,KAAK,kBAAkBA,QAAO;AAAA,MACrC,QAAQ,KAAK;AAAA,MACb,MAAM,KAAK,gBAAgBA,QAAO;AAAA,MAClC,OAAO,KAAK,WAAW;AAAA,MACvB,KAAK,KAAK,SAAS;AAAA,IACrB;AAAA,EACF;AAAA,EAMA,SAASA,UAAS;AAChB,WAAOA,SAAQ,IAAI,YAAY,KAAK,SAAS,GAAG,IAAI;AAAA,EACtD;AAAA,EAKA,OAAOA,UAAS;AACd,UAAM,QAAQ;AACd,UAAM,OAAO,KAAK,OAAOA,SAAQ,IAAI,iBAAiB,CAAC;AACvD,UAAM,gBAAgBA,SAAQ,IAAI,cAAc,MAAM,IAAI;AAC1D,UAAM,UAAUA,SAAQ,IAAI,WAAW,MAAM,KAAK;AAClD,UAAM,UAAU,KAAK,kBAAkBA,QAAO;AAC9C,UAAM,aAAa,CAAC;AACpB,UAAM,YAAYA,SAAQ,IAAI,aAAa,MAAM,KAAK;AACtD,UAAM,SAASA,SAAQ,IAAI,UAAU,MAAM,KAAK;AAChD,UAAM,MAAMA,SAAQ,IAAI,OAAO,MAAM,KAAK;AAC1C,UAAM,QAAQA,SAAQ,OAAO,cAAc,MAAM,KAAK;AACtD,UAAM,iBAAiBA,SAAQ,OAAO,UAAU,MAAM,KAAK;AAC3D,eAAW,OAAO;AAClB,QAAI,WAAW;AACb,iBAAW,QAAQ;AAAA,IACrB;AACA,QAAI,QAAQ;AACV,iBAAW,SAAS;AAAA,IACtB;AACA,QAAI,KAAK;AACP,iBAAW,MAAM;AAAA,IACnB;AACA,QAAI,OAAO;AACT,aAAO,YAAY,KAAK;AAAA,IAC1B;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAQA,SAAS,iBAAiB,MAAM,OAAO;AACrC,QAAM,cAAc,WAAW;AAAA,IAC7B,YAAY,OAAO,QAAQ;AACzB,YAAM,OAAO,MAAM;AACnB,WAAK,IAAI;AAAA,IACX;AAAA,EACF;AACA,aAAW,KAAK,OAAO;AACrB,UAAM,UAAU,KAAK,MAAM;AAAA,EAC7B;AACA,QAAM,IAAI;AACV,SAAO;AACT;AAKA,IAAM,QAAQ,iBAAiB,SAAS;AAAA,EACtC,QAAQ;AAAA,EACR,SAAS;AACP,WAAO,YAAY,KAAK,SAAS;AAAA,EACnC;AACF,CAAC;AAKD,IAAM,OAAO,iBAAiB,MAAM;AAMpC,IAAM,KAAK,iBAAiB,IAAI;AAMhC,IAAM,MAAM,iBAAiB,OAAO;AAAA,EAClC,QAAQ;AAAA,EAQR,OAAOD,SAAQ;AACb,QAAIA,YAAW,QAAQ;AACrB,MAAAA,UAAS,SAAS;AAAA,IACpB;AAEA,WAAO,KAAK,YAAY,IAAI,KAAK,IAAI,GAAGA,aAAY,KAAK;AAAA,EAC3D;AAAA,EAKA,cAAc;AACZ,UAAM,SAAS,KAAK;AACpB,WAAO,OAAO,UAAU,KAAK,OAAO,GAAG,MAAM,aAAa,OAAO,GAAG,MAAM;AAAA,EAC5E;AACF,CAAC;AAED,IAAI,QAAqB,OAAO,OAAO;AAAA,EACtC,WAAW;AAAA,EACX;AAAA,EACA,MAAM;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,CAAC;AAgBD,IAAM,YAAY,SAAO,IAAI,MAAM,GAAG;AAMtC,SAAS,OAAO,MAAM;AACpB,MAAI;AAAA,IACF;AAAA,EACF,IAAI;AAEJ,QAAM,cAAc,OAAO,OAAO,OAAO,CAAC,WAAW,UAAU,IAAI,WAAW,UAAU,OAAO,QAAQ,QAAQ,QAAQ,KAAK,SAAS,MAAM,MAAM,OAAO,OAAO,KAAK,OAAO,UAAU,CAAC;AAKtL,QAAM,iBAAiB,CAAC,YAAY,mBAAmB,YAAY,cAAc,YAAY,OAAO,OAAO,KAAK,aAAa,kBAAkB,WAAW,aAAa,WAAW,OAAO,OAAO,IAAI;AAIpM,QAAM,qBAAqB,CAAC,WAAW,YAAY,UAAU,WAAW,UAAU,OAAO,YAAY,QAAQ,QAAQ,QAAQ,WAAW,SAAS,MAAM,MAAM,OAAO,OAAO,OAAO,KAAK,OAAO,UAAU;AAMxM,QAAM,QAAQ,UAAU;AACxB,QAAM,YAAY,GAAG,OAAO,KAAK;AACjC,KAAG,WAAW,oBAAoB,SAAS;AAC3C,KAAG,WAAW,OAAO,QAAQ,SAAS;AACtC,QAAM,SAAS,UAAU,GACvB,SAAS,UAAU,GACnB,cAAc,UAAU;AAC1B,KAAG,OAAO,OAAO,QAAQ,MAAM;AAC/B,KAAG,OAAO,OAAO,QAAQ,MAAM;AAC/B,KAAG,OAAO,OAAO,aAAa,WAAW;AAEzC,KAAG,QAAQ,oBAAoB,SAAS;AACxC,KAAG,QAAQ,OAAO,QAAQ,MAAM;AAChC,QAAM,cAAc,GAAG,QAAQ,EAAE;AAEjC,KAAG,WAAW,IAAI,WAAW;AAG7B,KAAG,QAAQ,IAAI,WAAW;AAC1B,KAAG,aAAa,IAAI,WAAW;AAC/B,QAAM,eAAe,GAAG,WAAW,GAAG;AACtC,KAAG,cAAc,oBAAoB,SAAS;AAC9C,KAAG,cAAc,OAAO,QAAQ,SAAS;AACzC,QAAM,cAAc,UAAU;AAC9B,KAAG,aAAa,OAAO,QAAQ,WAAW;AAC1C,KAAG,aAAa,OAAO,QAAQ,WAAW;AAC1C,QAAM,iBAAiB,GAAG,aAAa,GAAG;AAC1C,KAAG,gBAAgB,OAAO,QAAQ,WAAW;AAC7C,QAAM,UAAU,UAAU,KAAK;AAC/B,KAAG,gBAAgB,OAAO,KAAK,OAAO;AACtC,KAAG,gBAAgB,OAAO,MAAM,OAAO;AACvC,KAAG,aAAa,WAAW,OAAO;AAGlC,QAAM,oBAAoB,GAAG,aAAa,MAAM;AAChD,KAAG,mBAAmB,OAAO,QAAQ,WAAW;AAChD,KAAG,SAAS,OAAO,QAAQ,WAAW;AACtC,KAAG,SAAS,KAAK,cAAc;AAC/B,KAAG,SAAS,QAAQ,iBAAiB;AAGrC,QAAM,aAAa,GAAG,SAAS,KAAK;AAEpC,KAAG,YAAY,OAAO,SAAS,KAAK;AAIpC,QAAM,eAAe,GAAG,QAAQ,MAAM;AACtC,QAAM,YAAY,GAAG,QAAQ,GAAG;AAChC,KAAG,cAAc,OAAO,QAAQ,MAAM;AACtC,KAAG,WAAW,oBAAoB,SAAS;AAC3C,KAAG,WAAW,OAAO,QAAQ,MAAM;AACnC,QAAM,eAAe,UAAU,GAAG;AAClC,KAAG,WAAW,OAAO,KAAK,YAAY;AACtC,KAAG,WAAW,OAAO,MAAM,YAAY;AACvC,KAAG,cAAc,OAAO,QAAQ,MAAM;AACtC,KAAG,cAAc,oBAAoB,SAAS;AAC9C,KAAG,cAAc,KAAK,SAAS;AAC/B,KAAG,cAAc,QAAQ,YAAY;AACrC,KAAG,cAAc,IAAI,WAAW;AAChC,QAAM,oBAAoB,GAAG,cAAc,KAAK;AAChD,QAAM,wBAAwB,UAAU,GAAG;AAC3C,KAAG,mBAAmB,OAAO,SAAS,qBAAqB;AAG3D,QAAM,QAAQ,UAAU,GAAG;AAG3B,QAAM,eAAe,UAAU;AAG/B,KAAG,OAAO,aAAa,KAAK;AAC5B,KAAG,OAAO,gBAAgB,YAAY;AACtC,KAAG,cAAc,aAAa,KAAK;AACnC,KAAG,cAAc,gBAAgB,YAAY;AAI7C,KAAG,cAAc,OAAO,KAAK;AAC7B,KAAG,uBAAuB,OAAO,KAAK;AAGtC,QAAM,cAAc,GAAG,QAAQ,KAAK;AACpC,QAAM,mBAAmB,GAAG,aAAa,KAAK;AAC9C,QAAM,wBAAwB,GAAG,kBAAkB,KAAK;AAExD,QAAM,YAAY,GAAG,uBAAuB,KAAK;AAGjD,KAAG,QAAQ,OAAO,QAAQ,MAAM;AAChC,KAAG,QAAQ,KAAK,SAAS;AACzB,KAAG,QAAQ,QAAQ,YAAY;AAC/B,KAAG,aAAa,OAAO,QAAQ,MAAM;AACrC,KAAG,aAAa,KAAK,SAAS;AAC9B,KAAG,aAAa,QAAQ,YAAY;AAGpC,KAAG,aAAa,OAAO,QAAQ,KAAK;AACpC,KAAG,aAAa,OAAO,KAAK;AAC5B,KAAG,WAAW,OAAO,QAAQ,KAAK;AAClC,KAAG,WAAW,aAAa,KAAK;AAChC,KAAG,WAAW,OAAO,KAAK;AAG1B,QAAM,eAAe,GAAG,OAAO,SAAS;AACxC,QAAM,iBAAiB,GAAG,OAAO,WAAW;AAC5C,QAAM,sBAAsB,GAAG,OAAO,gBAAgB;AACtD,QAAM,eAAe,GAAG,OAAO,SAAS;AAExC,KAAG,cAAc,WAAW,YAAY;AACxC,KAAG,cAAc,aAAa,cAAc;AAC5C,KAAG,cAAc,kBAAkB,mBAAmB;AACtD,KAAG,cAAc,WAAW,YAAY;AAGxC,KAAG,cAAc,YAAY,KAAK;AAClC,KAAG,gBAAgB,cAAc,KAAK;AACtC,KAAG,qBAAqB,mBAAmB,KAAK;AAChD,KAAG,cAAc,YAAY,KAAK;AAClC,KAAG,cAAc,YAAY,KAAK;AAKlC,QAAM,gBAAgB,UAAU,GAAG;AACnC,QAAM,kBAAkB,UAAU,GAAG;AACrC,QAAM,uBAAuB,UAAU,GAAG;AAC1C,QAAM,gBAAgB,UAAU,GAAG;AACnC,KAAG,cAAc,aAAa,aAAa;AAC3C,KAAG,gBAAgB,aAAa,eAAe;AAC/C,KAAG,qBAAqB,aAAa,oBAAoB;AACzD,KAAG,cAAc,aAAa,aAAa;AAC3C,QAAM,mBAAmB,UAAU;AACnC,QAAM,qBAAqB,UAAU;AACrC,QAAM,0BAA0B,UAAU;AAC1C,QAAM,mBAAmB,UAAU;AACnC,KAAG,cAAc,cAAc;AAC/B,KAAG,gBAAgB,cAAc;AACjC,KAAG,qBAAqB,cAAc;AACtC,KAAG,cAAc,cAAc;AAG/B,KAAG,eAAe,aAAa,aAAa;AAC5C,KAAG,iBAAiB,aAAa,eAAe;AAChD,KAAG,sBAAsB,aAAa,oBAAoB;AAC1D,KAAG,eAAe,aAAa,aAAa;AAC5C,KAAG,eAAe,gBAAgB,aAAa;AAC/C,KAAG,iBAAiB,gBAAgB,eAAe;AACnD,KAAG,sBAAsB,gBAAgB,oBAAoB;AAC7D,KAAG,eAAe,gBAAgB,aAAa;AAC/C,KAAG,kBAAkB,aAAa,gBAAgB;AAClD,KAAG,oBAAoB,aAAa,eAAe;AACnD,KAAG,yBAAyB,aAAa,oBAAoB;AAC7D,KAAG,kBAAkB,aAAa,aAAa;AAC/C,KAAG,kBAAkB,gBAAgB,gBAAgB;AACrD,KAAG,oBAAoB,gBAAgB,kBAAkB;AACzD,KAAG,yBAAyB,gBAAgB,uBAAuB;AACnE,KAAG,kBAAkB,gBAAgB,gBAAgB;AAGrD,KAAG,iBAAiB,cAAc,KAAK;AACvC,KAAG,sBAAsB,mBAAmB,KAAK;AACjD,KAAG,eAAe,YAAY,KAAK;AACnC,KAAG,eAAe,YAAY,KAAK;AACnC,KAAG,oBAAoB,cAAc,KAAK;AAC1C,KAAG,yBAAyB,mBAAmB,KAAK;AACpD,KAAG,kBAAkB,YAAY,KAAK;AACtC,KAAG,kBAAkB,YAAY,KAAK;AACtC,KAAG,OAAO,WAAW,YAAY;AACjC,KAAG,OAAO,MAAM,EAAE;AAElB,SAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AACF;AAYA,SAAS,IAAI,OAAO,OAAO,QAAQ;AACjC,MAAI,MAAM,OAAO;AACjB,MAAI,SAAS;AACb,MAAI,SAAS,CAAC;AACd,MAAI,aAAa,CAAC;AAClB,SAAO,SAAS,KAAK;AACnB,QAAI,QAAQ;AACZ,QAAI,cAAc;AAClB,QAAI,YAAY;AAChB,QAAI,cAAc;AAClB,QAAI,kBAAkB;AACtB,QAAI,eAAe;AACnB,WAAO,SAAS,OAAO,EAAE,cAAc,MAAM,GAAG,OAAO,QAAQ,CAAC,IAAI;AAGlE,iBAAW,KAAK,OAAO,SAAS;AAAA,IAClC;AACA,WAAO,SAAS,QAAQ,YAAY,eAAe,MAAM,GAAG,OAAO,QAAQ,CAAC,IAAI;AAE9E,oBAAc;AACd,cAAQ;AAGR,UAAI,MAAM,QAAQ,GAAG;AACnB,uBAAe;AACf,0BAAkB;AAAA,MACpB,WAAW,gBAAgB,GAAG;AAC5B;AAAA,MACF;AACA;AACA;AAAA,IACF;AACA,QAAI,eAAe,GAAG;AAIpB,gBAAU;AACV,UAAI,SAAS,KAAK;AAChB,mBAAW,KAAK,OAAO,OAAO;AAC9B;AAAA,MACF;AAAA,IACF,OAAO;AAGL,UAAI,WAAW,SAAS,GAAG;AACzB,eAAO,KAAK,eAAe,MAAM,OAAO,UAAU,CAAC;AACnD,qBAAa,CAAC;AAAA,MAChB;AAGA,gBAAU;AACV,qBAAe;AAGf,YAAM,QAAQ,gBAAgB;AAC9B,YAAM,YAAY,OAAO,MAAM,SAAS,aAAa,MAAM;AAC3D,aAAO,KAAK,eAAe,OAAO,OAAO,SAAS,CAAC;AAAA,IACrD;AAAA,EACF;AAGA,MAAI,WAAW,SAAS,GAAG;AACzB,WAAO,KAAK,eAAe,MAAM,OAAO,UAAU,CAAC;AAAA,EACrD;AACA,SAAO;AACT;AAUA,SAAS,eAAe,OAAO,OAAO,QAAQ;AAC5C,QAAM,WAAW,OAAO,GAAG;AAC3B,QAAM,SAAS,OAAO,OAAO,SAAS,GAAG;AACzC,QAAM,QAAQ,MAAM,MAAM,UAAU,MAAM;AAC1C,SAAO,IAAI,MAAM,OAAO,MAAM;AAChC;AAMA,IAAM,OAAO;AAAA,EACX,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,YAAY,CAAC;AAAA,EACb,aAAa,CAAC;AAAA,EACd,eAAe,CAAC;AAAA,EAChB,aAAa;AACf;AA+GA,SAAS,OAAO;AAEd,OAAK,UAAU,OAAO,KAAK,aAAa;AACxC,WAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAC/C,SAAK,WAAW,GAAG,GAAG;AAAA,MACpB,SAAS,KAAK;AAAA,IAChB,CAAC;AAAA,EACH;AAGA,OAAK,SAAS,OAAO,KAAK,QAAQ,MAAM;AACxC,WAAS,IAAI,GAAG,IAAI,KAAK,YAAY,QAAQ,KAAK;AAChD,SAAK,YAAY,GAAG,GAAG;AAAA,MACrB,SAAS,KAAK;AAAA,MACd,QAAQ,KAAK;AAAA,IACf,CAAC;AAAA,EACH;AACA,OAAK,cAAc;AACrB;AAOA,SAAS,SAAS,KAAK;AACrB,MAAI,CAAC,KAAK,aAAa;AACrB,SAAK;AAAA,EACP;AACA,SAAO,IAAI,KAAK,OAAO,OAAO,KAAK,MAAM,KAAK,QAAQ,OAAO,GAAG,CAAC;AACnE;;;AC9uDA,SAAS,WAAW,MAAM;AACxB,SAAO,KAAK,QAAQ,MAAM,OAAO,EAAE,QAAQ,MAAM,MAAM,EAAE,QAAQ,MAAM,MAAM;AAC/E;AACA,SAAS,WAAW,MAAM;AACxB,SAAO,KAAK,QAAQ,MAAM,QAAQ;AACpC;AACA,SAAS,mBAAmB,YAAY;AACtC,QAAM,SAAS,CAAC;AAChB,aAAW,QAAQ,YAAY;AAC7B,QAAI,MAAM,WAAW,QAAQ;AAC7B,WAAO,KAAK,GAAG,SAAS,WAAW,GAAG,IAAI;AAAA,EAC5C;AACA,SAAO,OAAO,KAAK,GAAG;AACxB;AACA,SAAS,cAAc,MAAM;AAC3B,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,SAAO,IAAI,WAAW,mBAAmB,UAAU,KAAK,WAAW,OAAO,MAAM;AAClF;AAWA,SAAS,WAAW,KAAK,MAAM;AAC7B,MAAI,SAAS,QAAQ;AACnB,WAAO,CAAC;AAAA,EACV;AACA,SAAO,IAAI,QAAQ,MAAM,aAAa;AACtC,QAAM,SAAS,SAAS,GAAG;AAC3B,QAAM,SAAS,CAAC;AAChB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,QAAQ,OAAO;AACrB,QAAI,MAAM,MAAM,QAAQ,KAAK,IAAI,OAAO,GAAG;AACzC,aAAO,KAAK,QAAQ;AAAA,IACtB,WAAW,CAAC,MAAM,UAAU,CAAC,KAAK,MAAM,KAAK,GAAG;AAC9C,aAAO,KAAK,WAAW,MAAM,SAAS,CAAC,CAAC;AAAA,IAC1C,OAAO;AACL,aAAO,KAAK,KAAK,OAAO,KAAK,CAAC;AAAA,IAChC;AAAA,EACF;AACA,SAAO,OAAO,KAAK,EAAE;AACvB;AACA,IAAI,CAAC,OAAO,UAAU,SAAS;AAC7B,SAAO,eAAe,OAAO,WAAW,WAAW;AAAA,IACjD,UAAU;AAAA,IACV,OAAO,SAAS,QAAQE,UAAS;AAC/B,aAAO,WAAW,MAAMA,QAAO;AAAA,IACjC;AAAA,EACF,CAAC;AACH;",
  "names": ["nextState", "regexp", "defaultRender", "scheme", "options", "options"]
}
